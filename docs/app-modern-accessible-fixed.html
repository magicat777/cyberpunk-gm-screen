<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cyberpunk RED - GM Screen (Accessible &amp; Fixed)</title>
    <link rel="stylesheet" href="css/styles-modern.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An accessible GM screen for Cyberpunk RED tabletop RPG with responsive design and keyboard navigation">
    
    <!-- Fix for notes panel save/load functionality -->
    <script>
        // Define consistent storage keys
        window.CYBERPUNK_STORAGE_KEYS = {
            notesContent: 'cyberpunk-notes-content',
            notesBackup: 'cyberpunk-notes-backup',
            layoutAutoSave: 'cyberpunk-layout-autosave',
            layoutDefault: 'cyberpunk-layout-default'
        };
        
        // Helper function to safely interact with localStorage
        window.safeStorage = {
            get: function(key, defaultValue = null) {
                try {
                    const item = localStorage.getItem(key);
                    return item !== null ? JSON.parse(item) : defaultValue;
                } catch (error) {
                    console.error(`Error retrieving ${key} from localStorage:`, error);
                    return defaultValue;
                }
            },
            
            set: function(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error(`Error saving ${key} to localStorage:`, error);
                    return false;
                }
            },
            
            // Special methods for HTML content that shouldn't be JSON-stringified
            getHTML: function(key, defaultValue = '') {
                try {
                    const item = localStorage.getItem(key);
                    return item !== null ? item : defaultValue;
                } catch (error) {
                    console.error(`Error retrieving HTML from ${key}:`, error);
                    return defaultValue;
                }
            },
            
            setHTML: function(key, htmlContent) {
                try {
                    localStorage.setItem(key, htmlContent);
                    return true;
                } catch (error) {
                    console.error(`Error saving HTML to ${key}:`, error);
                    return false;
                }
            },
            
            remove: function(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.error(`Error removing ${key} from localStorage:`, error);
                    return false;
                }
            }
        };
    </script>
    
    <!-- Ensure panel functions are always available -->
    <script>
        // Pre-define key functions to ensure they're available
        window.createNotesPanel = window.createNotesPanel || function() {
            // Creating notes panel with fallback
            
            // Get createPanel function from window if available
            const createPanelFunc = typeof window.createPanel === 'function' ? 
                window.createPanel : 
                function(title) {
                    // Create a proper panel
                    const panel = document.createElement('div');
                    panel.className = 'panel';
                    panel.style.width = '400px';
                    panel.style.height = '300px';
                    panel.style.position = 'absolute';
                    panel.style.left = '100px';
                    panel.style.top = '100px';
                    panel.style.zIndex = '1000';
                    panel.style.backgroundColor = 'rgba(30, 30, 45, 0.85)';
                    panel.style.border = '1px solid #00ccff';
                    panel.style.borderRadius = '4px';
                    panel.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.3)';
                    panel.style.overflow = 'hidden';
                    panel.style.display = 'flex';
                    panel.style.flexDirection = 'column';
                    
                    // Add HTML structure for panel
                    panel.innerHTML = `
                        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center; 
                             padding: 8px; background-color: rgba(10, 10, 20, 0.8); cursor: move; border-bottom: 1px solid #00ccff;">
                            <div>${title}</div>
                            <button class="close-button" style="background: none; border: none; color: #e0e0e0; 
                                    font-size: 18px; cursor: pointer;">&times;</button>
                        </div>
                        <div class="panel-content" style="flex: 1; overflow: auto; padding: 10px;"></div>
                        <div class="resize-handle" style="position: absolute; bottom: 0; right: 0; width: 15px; 
                             height: 15px; cursor: nwse-resize; background: transparent;"></div>
                    `;
                    
                    // Add panel to document body
                    document.body.appendChild(panel);
                    
                    // Add minimal dragging functionality
                    const header = panel.querySelector('.panel-header');
                    header.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        let startX = e.clientX;
                        let startY = e.clientY;
                        let startLeft = parseInt(panel.style.left) || 0;
                        let startTop = parseInt(panel.style.top) || 0;
                        
                        function movePanel(e) {
                            panel.style.left = (startLeft + e.clientX - startX) + 'px';
                            panel.style.top = (startTop + e.clientY - startY) + 'px';
                        }
                        
                        function stopMoving() {
                            document.removeEventListener('mousemove', movePanel);
                            document.removeEventListener('mouseup', stopMoving);
                        }
                        
                        document.addEventListener('mousemove', movePanel);
                        document.addEventListener('mouseup', stopMoving);
                    });
                    
                    // Add resize functionality
                    const resizeHandle = panel.querySelector('.resize-handle');
                    resizeHandle.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        let startX = e.clientX;
                        let startY = e.clientY;
                        let startWidth = parseInt(panel.style.width) || 400;
                        let startHeight = parseInt(panel.style.height) || 300;
                        
                        function resizePanel(e) {
                            panel.style.width = (startWidth + e.clientX - startX) + 'px';
                            panel.style.height = (startHeight + e.clientY - startY) + 'px';
                        }
                        
                        function stopResizing() {
                            document.removeEventListener('mousemove', resizePanel);
                            document.removeEventListener('mouseup', stopResizing);
                            panel.classList.remove('resizing');
                        }
                        
                        panel.classList.add('resizing');
                        document.addEventListener('mousemove', resizePanel);
                        document.addEventListener('mouseup', stopResizing);
                    });
                    
                    // Add close functionality
                    panel.querySelector('.close-button').addEventListener('click', function() {
                        panel.remove();
                    });
                    
                    return panel;
                };
            
            // Now create the actual panel
            const panel = createPanelFunc('Notes (Emergency Fallback)');
            const content = panel.querySelector('.panel-content');
            
            // Storage key for saving notes content - use consistent key from CYBERPUNK_STORAGE_KEYS
            const storageKey = window.CYBERPUNK_STORAGE_KEYS ? 
                window.CYBERPUNK_STORAGE_KEYS.notesContent : 
                'cyberpunk-notes-content';
            
            // Add a simple rich text editor with more formatting options
            content.innerHTML = `
                <div style="display: flex; flex-direction: column; height: 100%;">
                    <div style="padding: 5px; border-bottom: 1px solid rgba(0, 204, 255, 0.3); display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="btn-bold" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            <strong>B</strong>
                        </button>
                        <button id="btn-italic" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            <em>I</em>
                        </button>
                        <button id="btn-underline" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            <u>U</u>
                        </button>
                        <button id="btn-h1" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            H1
                        </button>
                        <button id="btn-h2" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            H2
                        </button>
                        <button id="btn-list" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            • List
                        </button>
                        <button id="btn-save" style="padding: 3px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0;">
                            Save
                        </button>
                    </div>
                    <div id="editor-content" contenteditable="true" style="flex: 1; padding: 10px; background: rgba(20,20,35,0.8); color: #e0e0e0; 
                                                        outline: none; overflow-y: auto; min-height: 200px;"></div>
                    <div style="padding: 3px; text-align: right; font-size: 12px; color: rgba(200, 200, 255, 0.7); border-top: 1px solid rgba(0, 204, 255, 0.2);">
                        <span id="notes-status">Ready</span>
                    </div>
                </div>
            `;
            
            // Add event listeners to buttons
            const editor = content.querySelector('#editor-content');
            const statusEl = content.querySelector('#notes-status');
            
            content.querySelector('#btn-bold').addEventListener('click', function() {
                document.execCommand('bold', false, null);
                editor.focus();
            });
            
            content.querySelector('#btn-italic').addEventListener('click', function() {
                document.execCommand('italic', false, null);
                editor.focus();
            });
            
            content.querySelector('#btn-underline').addEventListener('click', function() {
                document.execCommand('underline', false, null);
                editor.focus();
            });
            
            content.querySelector('#btn-h1').addEventListener('click', function() {
                document.execCommand('formatBlock', false, '<h1>');
                editor.focus();
            });
            
            content.querySelector('#btn-h2').addEventListener('click', function() {
                document.execCommand('formatBlock', false, '<h2>');
                editor.focus();
            });
            
            content.querySelector('#btn-list').addEventListener('click', function() {
                document.execCommand('insertUnorderedList', false, null);
                editor.focus();
            });
            
            content.querySelector('#btn-save').addEventListener('click', function() {
                // Use safeStorage if available, with fallback
                if (window.safeStorage && typeof window.safeStorage.setHTML === 'function') {
                    const success = window.safeStorage.setHTML(storageKey, editor.innerHTML);
                    
                    // Also save to backup key
                    if (success && window.CYBERPUNK_STORAGE_KEYS) {
                        window.safeStorage.setHTML(window.CYBERPUNK_STORAGE_KEYS.notesBackup, editor.innerHTML);
                    }
                    
                    statusEl.textContent = success ? 'Saved!' : 'Error saving';
                    if (!success) console.error('Error saving notes with safeStorage');
                } else {
                    try {
                        localStorage.setItem(storageKey, editor.innerHTML);
                        statusEl.textContent = 'Saved!';
                    } catch (err) {
                        statusEl.textContent = 'Error saving';
                        console.error('Error saving notes:', err);
                    }
                }
                
                setTimeout(() => { statusEl.textContent = 'Ready'; }, 2000);
            });
            
            // Auto-save functionality
            editor.addEventListener('input', function() {
                statusEl.textContent = 'Typing...';
                clearTimeout(editor.saveTimeout);
                editor.saveTimeout = setTimeout(function() {
                    // Use safeStorage if available, with fallback
                    if (window.safeStorage && typeof window.safeStorage.setHTML === 'function') {
                        const success = window.safeStorage.setHTML(storageKey, editor.innerHTML);
                        statusEl.textContent = success ? 'Auto-saved' : 'Auto-save failed';
                        if (!success) console.error('Error auto-saving notes with safeStorage');
                    } else {
                        try {
                            localStorage.setItem(storageKey, editor.innerHTML);
                            statusEl.textContent = 'Auto-saved';
                        } catch (err) {
                            statusEl.textContent = 'Auto-save failed';
                            console.error('Error auto-saving notes:', err);
                        }
                    }
                    
                    setTimeout(() => { statusEl.textContent = 'Ready'; }, 2000);
                }, 3000);
            });
            
            // Load any previously saved content with improved error handling and fallbacks
            let savedContent = null;
            let loadSuccess = false;
            
            // First try using safeStorage
            if (window.safeStorage && typeof window.safeStorage.getHTML === 'function') {
                savedContent = window.safeStorage.getHTML(storageKey);
                if (savedContent) {
                    loadSuccess = true;
                } else if (window.CYBERPUNK_STORAGE_KEYS) {
                    // Try backup key
                    savedContent = window.safeStorage.getHTML(window.CYBERPUNK_STORAGE_KEYS.notesBackup);
                    if (savedContent) loadSuccess = true;
                }
            }
            
            // Fall back to direct localStorage if needed
            if (!loadSuccess) {
                try {
                    savedContent = localStorage.getItem(storageKey);
                    if (savedContent) {
                        loadSuccess = true;
                    } else {
                        // Try legacy keys as fallback
                        const legacyKeys = [
                            'cyberpunk-emergency-notes',
                            'cyberpunk-notes-content',
                            'cyberpunk-notes-backup'
                        ];
                        
                        for (const key of legacyKeys) {
                            savedContent = localStorage.getItem(key);
                            if (savedContent) {
                                console.log(`Found notes in legacy storage key: ${key}`);
                                loadSuccess = true;
                                break;
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error loading saved notes:', err);
                }
            }
            
            // Apply content if found
            if (loadSuccess && savedContent) {
                editor.innerHTML = savedContent;
                console.log('Successfully loaded saved notes content');
            }
            
            // Focus the editor
            setTimeout(() => editor.focus(), 100);
            
            return panel;
        };
        
        // Debug functionality
        window.debugNotesPanel = window.debugNotesPanel || function() {
            console.log('Notes Panel Debug Info (emergency fallback):');
            console.log('- createNotesPanel function exists:', typeof window.createNotesPanel === 'function');
            console.log('- document.readyState:', document.readyState);
            return 'Debug info logged to console';
        };
    </script>
    
    <style>
        /* Font declarations for Display and Cyberpunk fonts */
        @font-face {
            font-family: 'Cyberpunk';
            src: url('fonts/Cyberpunk.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        @font-face {
            font-family: 'BladeRunner';
            src: url('fonts/Acquire.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        @font-face {
            font-family: 'Display';
            src: url('fonts/VeniteAdoremus.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        /* Fix for dropdown menus to appear on top of panels */
        /* Ensure toolbar is always on top */
        .toolbar {
            position: relative;
            z-index: 10000 !important; /* Highest z-index on the page */
        }
        
        .dropdown {
            position: relative;
            z-index: 9500 !important; /* The dropdown container itself needs a high z-index */
        }
        
        .dropdown-content {
            z-index: 9000 !important; /* Ensure dropdown menus are always on top of panels */
            position: absolute !important; /* Force absolute positioning */
            top: 100% !important; /* Position below the dropdown button */
            left: 0 !important; /* Align with left edge of dropdown button */
        }
        
        /* Force visible when active/hovered */
        .dropdown:hover .dropdown-content,
        .dropdown.active .dropdown-content,
        .dropdown-content.active {
            display: block !important;
            pointer-events: auto !important; /* Ensure the dropdown receives mouse events */
        }
        
        /* Fix for menus when hovering over panels */
        .dropdown-content.active {
            animation: none !important; /* Disable any fade animations */
            opacity: 1 !important; /* Ensure it's fully visible */
        }
        
        /* Ensure panels have a lower z-index than dropdowns, even when dragging */
        .panel, div[role="region"] {
            z-index: 1000; /* Lower than dropdown menus */
        }
        
        /* Override panel dragging z-index to be still lower than dropdowns */
        .panel-dragging, .dragging {
            z-index: 2000 !important; /* Higher than normal panels but lower than dropdowns */
        }
        
        /* Notification system styles */
        .cp-notifications {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
        }
        
        .cp-notification {
            background-color: var(--theme-panel-bg, rgba(30, 30, 45, 0.85));
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 10px 15px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            animation: cp-notification-fade 0.3s ease-out;
            margin-top: 5px;
        }
        
        /* Rich Text Editor for Notes Panel */
        .notes-editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            font-family: var(--font-content, sans-serif);
        }
        .notes-toolbar {
            background-color: rgba(30, 30, 45, 0.9);
            border-bottom: 1px solid var(--theme-primary, #00ccff);
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .notes-toolbar button {
            background-color: rgba(40, 40, 60, 0.9);
            color: var(--theme-text-primary, #e0e0e0);
            border: 1px solid var(--theme-primary, #00ccff);
            border-radius: 3px;
            padding: 3px 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .notes-toolbar button:hover {
            background-color: rgba(60, 60, 80, 0.9);
        }
        .notes-toolbar button.active {
            background-color: rgba(0, 150, 200, 0.5);
        }
        .notes-toolbar .separator {
            width: 1px;
            height: 20px;
            background-color: rgba(200, 200, 255, 0.3);
            margin: 0 5px;
        }
        .notes-editor {
            flex: 1;
            background-color: rgba(20, 20, 35, 0.8);
            border: none;
            color: var(--theme-text-primary, #e0e0e0);
            resize: none;
            padding: 10px;
            font-size: 14px;
            outline: none;
            overflow-y: auto;
            min-height: 200px;
            -webkit-user-select: text;
            user-select: text;
        }
        .notes-editor[contenteditable="true"] {
            cursor: text;
        }
        .notes-footer {
            padding: 5px;
            font-size: 12px;
            color: rgba(200, 200, 255, 0.7);
            text-align: right;
            border-top: 1px solid rgba(200, 200, 255, 0.2);
        }
        /* Custom styling for formatted text */
        .notes-editor b, .notes-editor strong {
            color: var(--theme-primary, #00ccff);
        }
        .notes-editor i, .notes-editor em {
            color: #ffcc00;
        }
        .notes-editor u {
            text-decoration-color: var(--theme-primary, #00ccff);
        }
        .notes-editor h1, .notes-editor h2, .notes-editor h3 {
            color: var(--theme-primary, #00ccff);
            border-bottom: 1px solid rgba(0, 204, 255, 0.3);
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .notes-editor h1 { font-size: 1.4em; }
        .notes-editor h2 { font-size: 1.2em; }
        .notes-editor h3 { font-size: 1.1em; }
        .notes-editor code {
            font-family: monospace;
            background-color: rgba(30, 30, 45, 0.9);
            padding: 2px 4px;
            border-radius: 3px;
            color: #ff5555;
        }
        .notes-editor pre {
            font-family: monospace;
            background-color: rgba(30, 30, 45, 0.9);
            padding: 5px;
            border-radius: 3px;
            color: #ff5555;
            white-space: pre-wrap;
        }
        .notes-editor a {
            color: #55aaff;
            text-decoration: underline;
        }
        .notes-editor ol, .notes-editor ul {
            padding-left: 20px;
        }
        
        .cp-notification-success {
            border-left: 4px solid #00cc66;
        }
        
        .cp-notification-error {
            border-left: 4px solid #ff3333;
        }
        
        .cp-notification-info {
            border-left: 4px solid #00ccff;
        }
        
        .cp-notification-hiding {
            animation: cp-notification-fade-out 0.3s ease-in forwards;
        }
        
        @keyframes cp-notification-fade {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes cp-notification-fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        
        /* Accessibility Improvements */
        .skip-link {
            position: absolute;
            left: -9999px;
            z-index: 999;
            padding: 1em;
            background-color: #f5f5f5;
            color: #333;
            text-decoration: none;
        }
        
        .skip-link:focus {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Panel fixes */
        .panel {
            position: absolute;
            min-width: 200px;
            min-height: 100px;
            background-color: var(--theme-panel-bg, rgba(30, 30, 45, 0.85));
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            transition: box-shadow 0.2s;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: var(--theme-header-bg, rgba(20, 20, 35, 0.9));
            color: var(--theme-text, #e0e0e0);
            cursor: move;
            -webkit-user-select: none; /* Safari compatibility */
            user-select: none;
            border-bottom: 1px solid var(--theme-accent, #00ccff);
        }
        
        .panel-title {
            font-weight: bold;
            font-size: 14px;
            flex-grow: 1;
        }
        
        .panel-content {
            flex-grow: 1;
            overflow: auto;
            padding: 12px;
        }
        
        .close-button {
            background: none;
            border: none;
            color: var(--theme-text, #e0e0e0);
            font-size: 20px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-button:hover {
            color: var(--theme-accent, #00ccff);
        }
        
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, var(--theme-accent, #00ccff) 50%);
        }
        
        .notes-textarea {
            width: 100%;
            height: 100%;
            min-height: 150px;
            border: none;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--theme-text, #e0e0e0);
            resize: none;
            font-family: inherit;
            font-size: inherit;
        }
        
        .panel:focus,
        .panel:focus-within {
            outline: 2px solid var(--theme-accent, #00ccff);
            box-shadow: 0 0 0 2px rgba(0, 204, 255, 0.3);
        }
        
        .panel-dragging {
            opacity: 0.8;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        
        .panel-resizing {
            transition: none;
        }
        
        /* Critical Injuries Panel Styles */
        .critical-injuries {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .critical-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .roll-critical-btn {
            background-color: rgba(255, 50, 50, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #ff3333);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .roll-critical-btn:hover {
            background-color: rgba(255, 50, 50, 0.4);
        }
        
        .critical-body-location {
            background-color: rgba(20, 20, 35, 0.7);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 7px 10px;
            border-radius: 4px;
        }
        
        .critical-result {
            background-color: rgba(50, 50, 70, 0.3);
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        
        .injury-card {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .injury-card h5 {
            color: var(--theme-accent, #ff3333);
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .injury-roll, .injury-location {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .injury-effect, .injury-recovery {
            margin-top: 5px;
        }
        
        .critical-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .critical-table th, .critical-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .critical-table th {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-accent, #00ccff);
        }
        
        .critical-table tr:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        /* Netrunning Panel Styles */
        .netrunning-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .netrunning-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--theme-accent, #00ccff);
        }
        
        .netrunning-tab {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-bottom: none;
            padding: 8px 15px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .netrunning-tab:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .netrunning-tab.active {
            background-color: rgba(0, 204, 255, 0.2);
            border-color: var(--theme-accent, #00ccff);
            color: var(--theme-accent, #00ccff);
        }
        
        .netrunning-tab-content {
            padding: 10px 0;
        }
        
        .netrunning-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
        }
        
        .create-net-architecture-btn {
            background-color: rgba(0, 255, 100, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00cc66;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
        }
        
        .create-net-architecture-btn:hover {
            background-color: rgba(0, 255, 100, 0.3);
        }
        
        .netrunning-difficulty, .netrunning-type {
            background-color: rgba(20, 20, 35, 0.7);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 7px 10px;
            border-radius: 4px;
            flex: 1;
        }
        
        .architecture-result {
            margin-top: 15px;
        }
        
        .net-architecture {
            background-color: rgba(50, 50, 70, 0.3);
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            padding: 15px;
        }
        
        .arch-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 204, 255, 0.3);
        }
        
        .arch-header h4 {
            margin: 0 0 10px 0;
            color: var(--theme-accent, #00ff66);
        }
        
        .arch-detail {
            font-size: 13px;
            margin-bottom: 5px;
            color: rgba(220, 220, 220, 0.9);
        }
        
        .arch-levels {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .arch-level {
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .level-number {
            background-color: rgba(0, 0, 0, 0.4);
            color: var(--theme-accent, #00ccff);
            padding: 5px 10px;
            font-weight: bold;
        }
        
        .level-content {
            padding: 10px;
        }
        
        .empty-level {
            color: rgba(220, 220, 220, 0.5);
            font-style: italic;
            padding: 5px;
        }
        
        .ice-component, .node-component {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .ice-component {
            border-left: 3px solid #ff3333;
        }
        
        .node-component {
            border-left: 3px solid #00cc66;
        }
        
        .component-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .ice-icon, .node-icon {
            margin-right: 10px;
            font-size: 16px;
        }
        
        .component-name {
            flex-grow: 1;
            font-weight: bold;
            color: var(--theme-text, #e0e0e0);
        }
        
        .component-difficulty, .component-security {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--theme-text, #e0e0e0);
        }
        
        .component-difficulty {
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.3);
        }
        
        .component-security {
            background-color: rgba(0, 204, 0, 0.2);
            border: 1px solid rgba(0, 204, 0, 0.3);
        }
        
        .component-effect {
            color: #ff6666;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .component-description {
            color: rgba(220, 220, 220, 0.8);
            font-size: 13px;
            font-style: italic;
        }
        
        .netrunning-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin: 10px 0;
        }
        
        .netrunning-table th, .netrunning-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .netrunning-table th {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-accent, #00ccff);
        }
        
        .netrunning-table tr:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        /* Enhanced Netrunning Panel Styles */
        .black-ice {
            border-left: 3px solid #ff3333 !important;
            background-color: rgba(255, 0, 0, 0.1) !important;
        }
        
        .boss-ice {
            border: 2px solid #ff3333 !important;
            background-color: rgba(255, 0, 0, 0.15) !important;
        }
        
        .saved-arch-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s;
        }
        
        .saved-arch-item:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .save-architecture-btn {
            background-color: rgba(0, 204, 255, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00ccff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .save-architecture-btn:hover {
            background-color: rgba(0, 204, 255, 0.4);
        }
        
        .ice-category-header {
            margin-top: 15px;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
            border-bottom: 1px solid var(--theme-accent, #00ccff);
            padding-bottom: 5px;
        }
        
        .component-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 5px 0;
            font-size: 12px;
            color: rgba(220, 220, 220, 0.8);
        }
        
        .stat {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .component-appearance, .component-value {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.7);
            margin-top: 5px;
        }
        
        .architecture-tip {
            font-style: italic;
            color: rgba(220, 220, 220, 0.7);
            font-size: 12px;
            margin-top: 10px;
        }
        
        .arch-description {
            font-style: italic;
            color: rgba(220, 220, 220, 0.8);
            margin-top: 10px;
            font-size: 13px;
        }
        
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .control-row label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            background-color: rgba(20, 20, 35, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* NPC Generator Styles */
        .npc-generator {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .npc-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--theme-accent, #00ccff);
        }
        
        .npc-tab {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-bottom: none;
            padding: 8px 15px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .npc-tab:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .npc-tab.active {
            background-color: rgba(0, 204, 255, 0.2);
            border-color: var(--theme-accent, #00ccff);
            color: var(--theme-accent, #00ccff);
        }
        
        .generator-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .generate-npc-btn, .save-npc-btn, .filter-button {
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
        }
        
        .generate-npc-btn {
            background-color: rgba(0, 255, 100, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00cc66;
        }
        
        .generate-npc-btn:hover {
            background-color: rgba(0, 255, 100, 0.3);
        }
        
        .save-npc-btn {
            background-color: rgba(0, 204, 255, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00ccff;
        }
        
        .save-npc-btn:hover {
            background-color: rgba(0, 204, 255, 0.3);
        }
        
        .filter-button {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .filter-button:hover {
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .npc-type, .npc-threat, .filter-type, .filter-threat {
            background-color: rgba(20, 20, 35, 0.7);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 7px 10px;
            border-radius: 4px;
            flex: 1;
        }
        
        .npc-card {
            background-color: rgba(50, 50, 70, 0.3);
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .npc-card.solo {
            border-left: 3px solid #ff3333;
        }
        
        .npc-card.netrunner {
            border-left: 3px solid #00ccff;
        }
        
        .npc-card.corporate {
            border-left: 3px solid #ffcc00;
        }
        
        .npc-card.boss {
            border: 2px solid #ff3333;
            background-color: rgba(255, 0, 0, 0.1);
        }
        
        .npc-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .npc-name-container {
            flex-grow: 1;
        }
        
        .npc-name {
            font-size: 18px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
            margin: 0;
        }
        
        .npc-type-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.3);
            margin-right: 5px;
        }
        
        .npc-threat-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .threat-goon {
            background-color: rgba(0, 204, 0, 0.2);
            border: 1px solid rgba(0, 204, 0, 0.3);
        }
        
        .threat-standard {
            background-color: rgba(255, 204, 0, 0.2);
            border: 1px solid rgba(255, 204, 0, 0.3);
        }
        
        .threat-lieutenant {
            background-color: rgba(255, 100, 0, 0.2);
            border: 1px solid rgba(255, 100, 0, 0.3);
        }
        
        .threat-boss {
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.3);
        }
        
        .npc-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .stat-box {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 10px;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: var(--theme-text, #e0e0e0);
        }
        
        .npc-skills, .npc-gear, .npc-cyberware, .npc-personality {
            margin-top: 12px;
        }
        
        .npc-section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
            margin-bottom: 5px;
        }
        
        .npc-skill-list, .npc-gear-list, .npc-cyberware-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .npc-skill, .npc-gear-item, .npc-cyberware-item {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .npc-skill {
            border: 1px solid rgba(0, 204, 255, 0.3);
        }
        
        .npc-gear-item {
            border: 1px solid rgba(255, 204, 0, 0.3);
        }
        
        .npc-cyberware-item {
            border: 1px solid rgba(255, 50, 255, 0.3);
        }
        
        .npc-personality {
            font-style: italic;
            color: rgba(220, 220, 220, 0.9);
            font-size: 13px;
        }
        
        .saved-npc-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s;
        }
        
        .saved-npc-item:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .npc-item-info {
            display: flex;
            flex-direction: column;
        }
        
        .npc-item-name {
            font-weight: bold;
            color: var(--theme-text, #e0e0e0);
        }
        
        .npc-item-type {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .npc-item-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .npc-load-btn, .npc-delete-btn {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .npc-load-btn {
            background-color: rgba(0, 204, 255, 0.2);
            border: 1px solid #00ccff;
            color: var(--theme-text, #e0e0e0);
        }
        
        .npc-delete-btn {
            background-color: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff3333;
            color: var(--theme-text, #e0e0e0);
        }
        
        .npc-placeholder {
            padding: 20px;
            text-align: center;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .npc-tip {
            font-style: italic;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* Loot Generator Styles */
        .loot-generator {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .loot-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--theme-accent, #00ccff);
        }
        
        .loot-tab {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-bottom: none;
            padding: 8px 15px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .loot-tab:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .loot-tab.active {
            background-color: rgba(0, 204, 255, 0.2);
            border-color: var(--theme-accent, #00ccff);
            color: var(--theme-accent, #00ccff);
        }
        
        .generate-loot-btn {
            background-color: rgba(0, 255, 100, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00cc66;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
        }
        
        .generate-loot-btn:hover {
            background-color: rgba(0, 255, 100, 0.3);
        }
        
        .save-loot-btn {
            background-color: rgba(0, 204, 255, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00ccff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .save-loot-btn:hover {
            background-color: rgba(0, 204, 255, 0.3);
        }
        
        .loot-value, .loot-type, .filter-category, .filter-rarity {
            background-color: rgba(20, 20, 35, 0.7);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 7px 10px;
            border-radius: 4px;
            flex: 1;
        }
        
        .loot-card {
            background-color: rgba(50, 50, 70, 0.3);
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .loot-collection-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .loot-collection-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
        }
        
        .loot-value-label {
            font-size: 14px;
            padding: 3px 8px;
            border-radius: 4px;
            background-color: rgba(0, 200, 100, 0.2);
            border: 1px solid rgba(0, 200, 100, 0.4);
        }
        
        .loot-container-description {
            font-style: italic;
            color: rgba(220, 220, 220, 0.8);
            margin-bottom: 15px;
            font-size: 14px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 3px solid var(--theme-accent, #00ccff);
        }
        
        .loot-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s;
        }
        
        .loot-item:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .loot-item-common {
            border-left: 3px solid #b0b0b0; /* gray */
        }
        
        .loot-item-uncommon {
            border-left: 3px solid #00cc66; /* green */
        }
        
        .loot-item-rare {
            border-left: 3px solid #00ccff; /* blue */
        }
        
        .loot-item-exotic {
            border-left: 3px solid #ff00cc; /* pink */
        }
        
        .loot-item-legendary {
            border-left: 3px solid #ffcc00; /* golden */
            background-color: rgba(255, 204, 0, 0.1);
        }
        
        .loot-item-info {
            display: flex;
            flex-direction: column;
        }
        
        .loot-item-name {
            font-weight: bold;
            color: var(--theme-text, #e0e0e0);
        }
        
        .loot-item-desc {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .loot-item-price {
            font-weight: bold;
            color: #00cc66;
        }
        
        .rarity-badge {
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-left: 6px;
        }
        
        .rarity-common {
            background-color: rgba(176, 176, 176, 0.2);
            border: 1px solid rgba(176, 176, 176, 0.4);
        }
        
        .rarity-uncommon {
            background-color: rgba(0, 204, 102, 0.2);
            border: 1px solid rgba(0, 204, 102, 0.4);
        }
        
        .rarity-rare {
            background-color: rgba(0, 204, 255, 0.2);
            border: 1px solid rgba(0, 204, 255, 0.4);
        }
        
        .rarity-exotic {
            background-color: rgba(255, 0, 204, 0.2);
            border: 1px solid rgba(255, 0, 204, 0.4);
        }
        
        .rarity-legendary {
            background-color: rgba(255, 204, 0, 0.2);
            border: 1px solid rgba(255, 204, 0, 0.4);
        }
        
        .saved-loot-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s;
        }
        
        .saved-loot-item:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .loot-item-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .loot-load-btn, .loot-delete-btn {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .loot-load-btn {
            background-color: rgba(0, 204, 255, 0.2);
            border: 1px solid #00ccff;
            color: var(--theme-text, #e0e0e0);
        }
        
        .loot-delete-btn {
            background-color: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff3333;
            color: var(--theme-text, #e0e0e0);
        }
        
        .loot-total {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-top: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-weight: bold;
        }
        
        .loot-placeholder {
            padding: 20px;
            text-align: center;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .loot-tip {
            font-style: italic;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .database-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .database-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .database-item-actions {
            margin-top: 8px;
            text-align: right;
        }
        
        .add-to-loot-btn {
            font-size: 12px;
            padding: 3px 8px;
            background-color: rgba(0, 204, 255, 0.2);
            border: 1px solid #00ccff;
            color: var(--theme-text, #e0e0e0);
            border-radius: 3px;
            cursor: pointer;
        }
        
        /* Location Generator Styles */
        .location-generator {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .location-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--theme-accent, #00ccff);
        }
        
        .location-tab {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-bottom: none;
            padding: 8px 15px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .location-tab:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .location-tab.active {
            background-color: rgba(0, 204, 255, 0.2);
            border-color: var(--theme-accent, #00ccff);
            color: var(--theme-accent, #00ccff);
        }
        
        .generate-location-btn {
            background-color: rgba(0, 255, 100, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00cc66;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
        }
        
        .generate-location-btn:hover {
            background-color: rgba(0, 255, 100, 0.3);
        }
        
        .save-location-btn {
            background-color: rgba(0, 204, 255, 0.2);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid #00ccff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .save-location-btn:hover {
            background-color: rgba(0, 204, 255, 0.3);
        }
        
        .location-type, .location-district {
            background-color: rgba(20, 20, 35, 0.7);
            color: var(--theme-text, #e0e0e0);
            border: 1px solid var(--theme-accent, #00ccff);
            padding: 7px 10px;
            border-radius: 4px;
            flex: 1;
        }
        
        .location-card {
            background-color: rgba(50, 50, 70, 0.3);
            border: 1px solid var(--theme-accent, #00ccff);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .location-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .location-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
            margin: 0;
        }
        
        .location-badges {
            display: flex;
            gap: 5px;
        }
        
        .location-type-badge, .location-district-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .location-type-badge {
            background-color: rgba(0, 204, 102, 0.2);
            border: 1px solid rgba(0, 204, 102, 0.4);
        }
        
        .location-district-badge {
            background-color: rgba(255, 204, 0, 0.2);
            border: 1px solid rgba(255, 204, 0, 0.4);
        }
        
        .security-level {
            display: inline-block;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 5px;
        }
        
        .security-low {
            background-color: rgba(0, 204, 0, 0.2);
            border: 1px solid rgba(0, 204, 0, 0.4);
        }
        
        .security-medium {
            background-color: rgba(255, 204, 0, 0.2);
            border: 1px solid rgba(255, 204, 0, 0.4);
        }
        
        .security-high {
            background-color: rgba(255, 100, 0, 0.2);
            border: 1px solid rgba(255, 100, 0, 0.4);
        }
        
        .security-extreme {
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.4);
        }
        
        .location-description {
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .location-section {
            margin: 15px 0;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--theme-accent, #00ccff);
            margin-bottom: 5px;
        }
        
        .npc-list, .hook-list, .threat-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .npc-item, .hook-item, .threat-item {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 8px;
        }
        
        .npc-item {
            border-left: 3px solid rgba(0, 204, 255, 0.5);
        }
        
        .hook-item {
            border-left: 3px solid rgba(255, 204, 0, 0.5);
        }
        
        .threat-item {
            border-left: 3px solid rgba(255, 50, 50, 0.5);
        }
        
        .npc-name, .hook-title, .threat-name {
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .npc-role, .hook-description, .threat-description {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.8);
        }
        
        .saved-location-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s;
        }
        
        .saved-location-item:hover {
            background-color: rgba(0, 204, 255, 0.1);
        }
        
        .location-item-info {
            display: flex;
            flex-direction: column;
        }
        
        .location-item-name {
            font-weight: bold;
            color: var(--theme-text, #e0e0e0);
        }
        
        .location-item-details {
            font-size: 12px;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .location-item-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .location-load-btn, .location-delete-btn {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .location-load-btn {
            background-color: rgba(0, 204, 255, 0.2);
            border: 1px solid #00ccff;
            color: var(--theme-text, #e0e0e0);
        }
        
        .location-delete-btn {
            background-color: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff3333;
            color: var(--theme-text, #e0e0e0);
        }
        
        .location-placeholder {
            padding: 20px;
            text-align: center;
            color: rgba(220, 220, 220, 0.7);
        }
        
        .location-tip {
            font-style: italic;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* District Map Styles */
        .district-map {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        
        .district-map-container {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 15px;
        }
        
        .district-details {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 15px;
        }
        
        .night-city-map {
            width: 100%;
            height: auto;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        
        .district {
            fill: rgba(50, 50, 70, 0.7);
            stroke: var(--theme-accent, #00ccff);
            stroke-width: 1;
            transition: fill 0.2s;
            cursor: pointer;
        }
        
        .district:hover {
            fill: rgba(0, 204, 255, 0.3);
        }
        
        .district.active {
            fill: rgba(0, 204, 255, 0.5);
            stroke-width: 2;
        }
        
        .district-label {
            fill: var(--theme-text, #e0e0e0);
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .district-name {
            color: var(--theme-accent, #00ccff);
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .district-description, .district-danger-level, .district-common-locations {
            margin-bottom: 15px;
        }
        
        .danger-level {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .danger-low {
            background-color: rgba(0, 204, 0, 0.2);
            border: 1px solid rgba(0, 204, 0, 0.4);
        }
        
        .danger-medium {
            background-color: rgba(255, 204, 0, 0.2);
            border: 1px solid rgba(255, 204, 0, 0.4);
        }
        
        .danger-high {
            background-color: rgba(255, 100, 0, 0.2);
            border: 1px solid rgba(255, 100, 0, 0.4);
        }
        
        .danger-extreme {
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.4);
        }
    </style>
</head>
<body class="theme-neon-synthwave">
    <!-- Skip to content link -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to content</a>
    
    <!-- Toolbar with dropdown menus -->
    <div class="toolbar" role="navigation" aria-label="Main Navigation">
        <div class="title">Cyberpunk RED GM Screen</div>
        
        <!-- Panel menu -->
        <div class="dropdown">
            <button class="dropbtn" aria-haspopup="true" aria-expanded="false" aria-controls="panel-menu">Add Panel</button>
            <div class="dropdown-content" id="panel-menu">
                <div class="menu-category" role="separator" aria-label="GM Tools Category">GM Tools</div>
                <a href="#" id="add-notes">Notes</a>
                <a href="#" id="add-dice">Dice Roller</a>
                <a href="#" id="add-initiative">Initiative Tracker</a>
                <a href="#" id="add-timer">Game Timer</a>
                <a href="#" id="add-calculator">Calculator</a>
                
                <div class="menu-category" role="separator" aria-label="Reference Category">Reference</div>
                <a href="#" id="add-rules">Rules Reference</a>
                <a href="#" id="add-weapons">Weapons Table</a>
                <a href="#" id="add-armor">Armor Table</a>
                <a href="#" id="add-critical">Critical Injuries</a>
                <a href="#" id="add-netrunning">Netrunning</a>
                
                <div class="menu-category" role="separator" aria-label="Characters Category">Characters</div>
                <a href="#" id="add-character">Character Sheet</a>
                <a href="#" id="add-npc">NPC Generator</a>
                <a href="#" id="add-loot">Loot Generator</a>
                
                <div class="menu-category" role="separator" aria-label="World Category">World</div>
                <a href="#" id="add-map">Night City Map</a>
                <a href="#" id="add-location">Location Generator</a>
                <a href="#" id="add-encounter">Random Encounter</a>
            </div>
        </div>
        
        <!-- Layout menu -->
        <div class="dropdown">
            <button class="dropbtn" aria-haspopup="true" aria-expanded="false" aria-controls="layout-menu">Layout</button>
            <div class="dropdown-content" id="layout-menu">
                <a href="#" id="clear-layout">Clear Layout</a>
                <a href="#" id="auto-organize">Auto-Organize</a>
                <a href="#" id="fit-to-window">Fit to Window</a>
                <div class="menu-category" role="separator">Save & Load</div>
                <a href="#" id="app-export-layout">Export Layout</a>
                <a href="#" id="app-import-layout">Import Layout</a>
                <a href="#" id="app-toggle-autosave">Auto-Save: On</a>
            </div>
        </div>
        
        <!-- Settings menu -->
        <div class="dropdown">
            <button class="dropbtn" aria-haspopup="true" aria-expanded="false" aria-controls="settings-menu">Settings</button>
            <div class="dropdown-content" id="settings-menu">
                <a href="#" id="toggle-animations">Toggle Animations</a>
                <a href="#" id="show-font-settings">Font Settings</a>
                <a href="#" id="test-storage">Test Storage</a>
                <a href="#" id="about">About</a>
                <a href="#" id="test-layout">Test Layout System</a>
            </div>
        </div>
        
        <!-- Theme switcher -->
        <div class="theme-switcher" role="radiogroup" aria-label="Theme Selection">
            <label id="theme-label">Theme:</label>
            <div class="theme-options">
                <div class="theme-option theme-neon active" data-theme="neon-synthwave" title="Neon Synthwave" role="radio" aria-checked="true" tabindex="0" aria-labelledby="theme-label"></div>
                <div class="theme-option theme-noir" data-theme="tech-noir" title="Tech Noir" role="radio" aria-checked="false" tabindex="0" aria-labelledby="theme-label"></div>
                <div class="theme-option theme-minimal" data-theme="minimal" title="Minimal" role="radio" aria-checked="false" tabindex="0" aria-labelledby="theme-label"></div>
            </div>
        </div>
    </div>
    
    <!-- Font controls -->
    <div class="font-settings-panel" role="dialog" aria-labelledby="font-settings-title">
        <div class="font-controls-header">
            <span id="font-settings-title">Font Settings</span>
            <button class="close-button" id="close-font-controls" aria-label="Close font settings">&times;</button>
        </div>
        
        <div class="font-options">
            <label id="font-size-label" for="font-size-group">Font Size</label>
            <div class="font-buttons" id="font-size-group" role="radiogroup" aria-labelledby="font-size-label">
                <button class="font-size-btn" id="font-size-tiny" data-size="10" role="radio" aria-checked="false">Tiny</button>
                <button class="font-size-btn" id="font-size-small" data-size="14" role="radio" aria-checked="false">Small</button>
                <button class="font-size-btn active" id="font-size-medium" data-size="16" role="radio" aria-checked="true">Medium</button>
                <button class="font-size-btn" id="font-size-large" data-size="20" role="radio" aria-checked="false">Large</button>
            </div>
        </div>
        
        <div class="font-options">
            <label id="font-family-label" for="font-family">Font Family</label>
            <select id="font-family" name="font-family">
                <option value="monospace, 'Consolas', 'Courier New'">Monospace</option>
                <option value="'Segoe UI', 'Roboto', sans-serif">Sans-serif</option>
                <option value="'Display', 'VeniteAdoremus', serif">Display</option>
                <option value="'Cyberpunk', 'BladeRunner', sans-serif">Cyberpunk</option>
            </select>
        </div>
        
        <div class="font-actions">
            <button id="apply-font" class="action-button primary-button">Apply</button>
            <button id="save-font" class="action-button">Save</button>
            <button id="load-font" class="action-button">Load</button>
            <button id="reset-font" class="action-button">Reset</button>
        </div>
        
        <div class="font-preview">
            <h3>Preview</h3>
            <p id="font-preview-text">The quick brown fox jumps over the lazy dog.</p>
        </div>
    </div>

    <!-- Main content area - panels will be dynamically added here -->
    <main id="main-content" role="main">
        <!-- Panels will be inserted here by JavaScript -->
    </main>

    <!-- Notification container -->
    <div class="cp-notifications" aria-live="polite"></div>
    
    <!-- Debug Tools (hidden in production) -->
    <div id="debug-tools" style="position: fixed; bottom: 10px; left: 10px; z-index: 9999; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ccff; border-radius: 4px;" role="region" aria-labelledby="debug-tools-title">
        <h4 id="debug-tools-title" style="color: #00ccff; margin: 0 0 10px 0; font-size: 14px;">Debug Tools</h4>
        <div class="debug-buttons">
            <button id="debug-notes-panel" style="background: #333; color: #fff; border: 1px solid #00ccff; padding: 5px; cursor: pointer; margin-right: 5px;">Debug Notes Panel</button>
            <button id="create-notes-panel" style="background: #333; color: #fff; border: 1px solid #00ccff; padding: 5px; cursor: pointer; margin-right: 5px;">Create Notes Panel</button>
            <button id="check-dependencies" style="background: #333; color: #fff; border: 1px solid #00ccff; padding: 5px; cursor: pointer;">Check Dependencies</button>
        </div>
        <div id="debug-output" style="margin-top: 10px; color: #fff; font-size: 12px; max-height: 100px; overflow-y: auto;" aria-live="polite"></div>
    </div>
    
    <!-- Debug script for troubleshooting -->
    <script>
        // Add event listeners when document is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Debug tools initialized');
            
            // Debug Notes Panel button
            document.getElementById('debug-notes-panel').addEventListener('click', function() {
                try {
                    // Define a debug function directly in case the one in the JS file isn't available
                    const debugFunc = function() {
                        console.log('Notes Panel Debug Info (inline):');
                        console.log('- createNotesPanel function exists:', typeof window.createNotesPanel === 'function');
                        console.log('- createPanel function exists:', typeof window.createPanel === 'function');
                        console.log('- safeCreatePanel function exists:', typeof window.safeCreatePanel === 'function');
                        console.log('- document.readyState:', document.readyState);
                        
                        // Check for HTML element with id="add-notes"
                        const addNotesLink = document.getElementById('add-notes');
                        console.log('- add-notes link exists:', !!addNotesLink);
                        if (addNotesLink) {
                            console.log('  - add-notes link text:', addNotesLink.textContent);
                        }
                        
                        // Check script loading
                        const scripts = Array.from(document.querySelectorAll('script'));
                        console.log('- Loaded scripts:', scripts.map(s => s.src).filter(src => src));
                        
                        return 'Debug info logged to console';
                    };
                    
                    // Try window function first, fall back to inline function
                    const result = (typeof window.debugNotesPanel === 'function') ? 
                        window.debugNotesPanel() : debugFunc();
                    
                    document.getElementById('debug-output').textContent = 'Debug info logged to console';
                } catch (e) {
                    document.getElementById('debug-output').textContent = 'Error: ' + e.message;
                    console.error('Debug error:', e);
                }
            });
            
            // Create Notes Panel button
            document.getElementById('create-notes-panel').addEventListener('click', function() {
                try {
                    // Create an inline version of createNotesPanel as fallback
                    const createNotesPanelFallback = function() {
                        console.log('Creating notes panel with fallback function');
                        
                        // Get panel creation functions, checking all possible locations
                        const createPanelFunc = 
                            (typeof window.createPanel === 'function') ? window.createPanel : 
                            (typeof createPanel === 'function') ? createPanel : 
                            function(title) {
                                // Super basic fallback
                                const div = document.createElement('div');
                                div.className = 'panel';
                                div.innerHTML = `
                                    <div class="panel-header">${title}</div>
                                    <div class="panel-content">
                                        <textarea style="width: 100%; height: 200px;"></textarea>
                                    </div>
                                `;
                                return div;
                            };
                        
                        // Create the panel
                        const panel = createPanelFunc('Notes (Manual)');
                        return panel;
                    };
                    
                    // Try the window function first, fall back to our inline version
                    const panel = (typeof window.createNotesPanel === 'function') ? 
                        window.createNotesPanel() : createNotesPanelFallback();
                    
                    document.getElementById('main-content').appendChild(panel);
                    document.getElementById('debug-output').textContent = 'Notes panel created manually';
                    console.log('Notes panel created manually:', panel);
                } catch (e) {
                    document.getElementById('debug-output').textContent = 'Error: ' + e.message;
                    console.error('Error creating notes panel:', e);
                }
            });
            
            // Check Dependencies button
            document.getElementById('check-dependencies').addEventListener('click', function() {
                const output = document.getElementById('debug-output');
                output.innerHTML = '';
                
                // Check for key functions
                const functions = ['createPanel', 'safeCreatePanel', 'createNotesPanel'];
                functions.forEach(func => {
                    const li = document.createElement('div');
                    li.textContent = `${func}: ${typeof window[func] === 'function' ? '✓' : '✗'}`;
                    li.style.color = typeof window[func] === 'function' ? '#5f5' : '#f55';
                    output.appendChild(li);
                });
                
                // Check for script loading
                const scripts = ['panel-implementations-fixed.js', 'ui-fix.js', 'app-modern-adapter-fixed.js'];
                scripts.forEach(script => {
                    const exists = Array.from(document.querySelectorAll('script')).some(s => 
                        s.src && s.src.includes(script));
                    const li = document.createElement('div');
                    li.textContent = `${script}: ${exists ? '✓' : '✗'}`;
                    li.style.color = exists ? '#5f5' : '#f55';
                    output.appendChild(li);
                });
            });
        });
    </script>

    <!-- Only load our standalone adapter - no dependency on app-modern.js -->
    <!-- Initialize CyberpunkGM namespace -->
    <script>
        // Ensure the CyberpunkGM namespace is available
        window.CyberpunkGM = window.CyberpunkGM || {};
        console.log('CyberpunkGM namespace initialized');
    </script>
    
    <!-- Load adapter script first -->
    <script src="js/app-modern-adapter-fixed.js"></script>
    
    <!-- Load panel implementations -->
    <script src="js/panel-implementations-fixed.js"></script>
    
    <!-- Load UI fixes and panel menu configuration -->
    <script src="js/ui-fix.js"></script>
    
    <!-- 
    Notes Panel Feature Implementation:
    The Notes Panel includes a rich text editor with:
    - Formatting toolbar (bold, italic, underline, headings, lists)
    - Keyboard shortcuts (Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+S)
    - Auto-save functionality
    - Persistent storage using localStorage
    -->
    
    <!-- Load layout-save-improved.js for layout functionality -->
    <script src="js/layout-save-improved.js"></script>
    
    <!-- Define global layout functions -->
    <script>
        /**
         * Global layout functions for accessibility and compatibility
         * These functions are defined in the global scope for direct access
         */
        
        // Define global layout functions
        function defineGlobalLayoutFunctions() {
            console.log('Defining global layout functions...');

            // Clear layout (remove all panels)
            window.clearLayout = function() {
                // Get all panels (support both .panel and div[role="region"] selectors)
                const panels = document.querySelectorAll('.panel, div[role="region"]');
                
                // Ask for confirmation first
                if (panels.length > 0) {
                    if (confirm('Are you sure you want to remove all panels?')) {
                        // Remove each panel
                        panels.forEach(panel => {
                            panel.remove();
                        });
                        
                        console.log('All panels cleared');
                        
                        // Show notification
                        showNotification('All panels removed', 'success');
                        return true;
                    }
                } else {
                    // No panels to clear
                    showNotification('No panels to clear', 'info');
                }
                return false;
            };
            
            // Auto-organize panels
            window.autoOrganizePanels = function() {
                console.log('Auto-organizing panels...');
                const panels = document.querySelectorAll('.panel, div[role="region"]');
                
                if (panels.length === 0) {
                    showNotification('No panels to organize', 'warning');
                    return;
                }
                
                // Calculate the number of rows and columns for a grid layout
                const count = panels.length;
                const columns = Math.ceil(Math.sqrt(count));
                const rows = Math.ceil(count / columns);
                
                // Get viewport dimensions minus toolbar height
                const toolbar = document.querySelector('.toolbar');
                const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight - toolbarHeight - 40; // 40px for margin
                
                // Calculate panel dimensions
                const panelWidth = Math.floor(viewportWidth / columns) - 20; // 20px for padding
                const panelHeight = Math.floor(viewportHeight / rows) - 20; // 20px for padding
                
                // Position panels in grid
                panels.forEach((panel, index) => {
                    const row = Math.floor(index / columns);
                    const col = index % columns;
                    
                    // Set position
                    panel.style.left = (col * (panelWidth + 20) + 10) + 'px'; // 10px margin on each side
                    panel.style.top = (toolbarHeight + row * (panelHeight + 20) + 10) + 'px'; // 10px margin on each side
                    
                    // Set dimensions
                    panel.style.width = panelWidth + 'px';
                    panel.style.height = panelHeight + 'px';
                });
                
                showNotification('Panels organized in grid layout', 'success');
            };
            
            // Fit panels to window
            window.fitPanelsToWindow = function() {
                console.log('Fitting panels to window...');
                const panels = document.querySelectorAll('.panel, div[role="region"]');
                
                if (panels.length === 0) {
                    showNotification('No panels to fit', 'warning');
                    return;
                }
                
                // Get viewport dimensions minus toolbar height
                const toolbar = document.querySelector('.toolbar');
                const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight - toolbarHeight - 40; // 40px for margin
                
                // Group panels by type
                const panelTypes = {};
                panels.forEach(panel => {
                    // Try to determine panel type from different attributes
                    let type = panel.getAttribute('data-panel-type') || 
                              panel.getAttribute('data-panel') || 
                              'unknown';
                    
                    // If we have a panel title element, use that instead
                    const titleElem = panel.querySelector('.panel-header') || 
                                    panel.querySelector('.panel-title') ||
                                    panel.querySelector('h2');
                    if (titleElem) {
                        type = titleElem.textContent.trim().toLowerCase().replace(/\s+/g, '-');
                    }
                    
                    if (!panelTypes[type]) {
                        panelTypes[type] = [];
                    }
                    panelTypes[type].push(panel);
                });
                
                const typeCount = Object.keys(panelTypes).length;
                let cols, rows;
                
                // Determine grid layout based on type count
                if (typeCount <= 2) {
                    cols = typeCount;
                    rows = 1;
                } else if (typeCount <= 6) {
                    cols = Math.ceil(typeCount / 2);
                    rows = 2;
                } else {
                    cols = Math.ceil(typeCount / 3);
                    rows = 3;
                }
                
                // Calculate cell dimensions
                const cellWidth = Math.floor(viewportWidth / cols);
                const cellHeight = Math.floor(viewportHeight / rows);
                
                // Position panel groups
                let typeIndex = 0;
                for (const type in panelTypes) {
                    const row = Math.floor(typeIndex / cols);
                    const col = typeIndex % cols;
                    const typePanels = panelTypes[type];
                    
                    // Calculate top-left corner of this cell
                    const cellTop = toolbarHeight + row * cellHeight + 10;
                    const cellLeft = col * cellWidth + 10;
                    
                    // If only one panel in this type, it fills the cell
                    if (typePanels.length === 1) {
                        const panel = typePanels[0];
                        panel.style.left = cellLeft + 'px';
                        panel.style.top = cellTop + 'px';
                        panel.style.width = (cellWidth - 20) + 'px';
                        panel.style.height = (cellHeight - 20) + 'px';
                    } else {
                        // Multiple panels - arrange in subcell grid
                        const subPanelCount = typePanels.length;
                        const subCols = Math.ceil(Math.sqrt(subPanelCount));
                        const subRows = Math.ceil(subPanelCount / subCols);
                        
                        const subCellWidth = Math.floor(cellWidth / subCols);
                        const subCellHeight = Math.floor(cellHeight / subRows);
                        
                        typePanels.forEach((panel, subIndex) => {
                            const subRow = Math.floor(subIndex / subCols);
                            const subCol = subIndex % subCols;
                            
                            panel.style.left = (cellLeft + subCol * subCellWidth) + 'px';
                            panel.style.top = (cellTop + subRow * subCellHeight) + 'px';
                            panel.style.width = (subCellWidth - 20) + 'px';
                            panel.style.height = (subCellHeight - 20) + 'px';
                        });
                    }
                    
                    typeIndex++;
                }
                
                showNotification('Panels fitted to window by type', 'success');
            };
        }
        
        // Call the function to define global layout functions
        defineGlobalLayoutFunctions();

























































































































































































            // Calculate grid dimensions
            const totalPanels = sortedPanels.length;
            const cols = Math.ceil(Math.sqrt(totalPanels)); // Square-ish grid
            
            // Calculate available space
            const containerWidth = window.innerWidth - 40; // 20px margin on each side
            const toolbarHeight = document.querySelector('.toolbar').offsetHeight || 0;
            const containerHeight = window.innerHeight - toolbarHeight - 40; // 20px margin on each side
            
            // Calculate panel dimensions
            const panelWidth = Math.floor(containerWidth / cols);
            const panelHeight = Math.floor(containerHeight / Math.ceil(totalPanels / cols));
            
            // Position panels
            sortedPanels.forEach((panel, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                panel.style.left = (20 + col * panelWidth) + 'px';
                panel.style.top = (toolbarHeight + 20 + row * panelHeight) + 'px';
                panel.style.width = (panelWidth - 20) + 'px'; // 10px gap on each side
                panel.style.height = (panelHeight - 20) + 'px'; // 10px gap on each side
                panel.style.zIndex = index + 10;
            });
            
            showNotification('Panels organized');
        };
        
        window.fitPanelsToWindow = function() {
            const panels = document.querySelectorAll('.panel, div[role="region"]');
            if (panels.length === 0) {
                showNotification('No panels to fit', 'info');
                return;
            }
            
            // Get available space
            const containerWidth = window.innerWidth - 40; // 20px margin on each side
            const toolbarHeight = document.querySelector('.toolbar').offsetHeight || 0;
            const containerHeight = window.innerHeight - toolbarHeight - 40; // 20px margin on each side
            
            // Group panels by type
            const panelGroups = {};
            
            panels.forEach(panel => {
                // Try different selectors to find panel titles
                const getTitleText = (panel) => {
                    const selectors = [
                        '.panel-header div',                  // Standard selector
                        '.panel-title',                       // Accessible version
                        '[role="heading"]',                   // ARIA role
                        'h2, h3, h4'                          // Basic headings
                    ];
                    
                    for (const selector of selectors) {
                        const element = panel.querySelector(selector);
                        if (element && element.textContent) {
                            return element.textContent.trim();
                        }
                    }
                    
                    // Fallback to panel ID or default text
                    return panel.id || panel.getAttribute('aria-label') || 'Untitled Panel';
                };
                
                const title = getTitleText(panel);
                const type = title.toLowerCase().replace(/\s+/g, '-');
                
                if (!panelGroups[type]) {
                    panelGroups[type] = [];
                }
                panelGroups[type].push(panel);
            });
            
            const types = Object.keys(panelGroups);
            const totalTypes = types.length;
            
            // Calculate grid dimensions based on number of types
            let rows, cols;
            
            if (totalTypes <= 2) {
                rows = 1;
                cols = totalTypes;
            } else if (totalTypes <= 6) {
                rows = 2;
                cols = Math.ceil(totalTypes / 2);
            } else {
                rows = 3;
                cols = Math.ceil(totalTypes / 3);
            }
            
            // Calculate cell dimensions
            const cellWidth = Math.floor(containerWidth / cols);
            const cellHeight = Math.floor(containerHeight / rows);
            
            // Position panels
            types.forEach((type, typeIndex) => {
                const row = Math.floor(typeIndex / cols);
                const col = typeIndex % cols;
                
                const typePanels = panelGroups[type];
                const panelCount = typePanels.length;
                
                if (panelCount === 1) {
                    // Single panel - fill the cell
                    const panel = typePanels[0];
                    
                    panel.style.left = (20 + col * cellWidth) + 'px';
                    panel.style.top = (toolbarHeight + 20 + row * cellHeight) + 'px';
                    panel.style.width = (cellWidth - 40) + 'px';
                    panel.style.height = (cellHeight - 40) + 'px';
                    panel.style.zIndex = typeIndex + 10;
                } else {
                    // Multiple panels - create sub-grid
                    const subRows = Math.ceil(Math.sqrt(panelCount));
                    const subCols = Math.ceil(panelCount / subRows);
                    
                    const subCellWidth = Math.floor(cellWidth / subCols);
                    const subCellHeight = Math.floor(cellHeight / subRows);
                    
                    typePanels.forEach((panel, panelIndex) => {
                        const subRow = Math.floor(panelIndex / subCols);
                        const subCol = panelIndex % subCols;
                        
                        panel.style.left = (20 + col * cellWidth + subCol * subCellWidth) + 'px';
                        panel.style.top = (toolbarHeight + 20 + row * cellHeight + subRow * subCellHeight) + 'px';
                        panel.style.width = (subCellWidth - 40) + 'px';
                        panel.style.height = (subCellHeight - 40) + 'px';
                        panel.style.zIndex = typeIndex + 10;
                    });
                }
            });
            
            showNotification('Panels fitted to window');
        };
        
        // Current version of the layout format
        const CURRENT_LAYOUT_VERSION = '1.1';
        
        /**
         * Gathers the current layout information from the DOM
         * Separating this from the export function for better modularity
         * @returns {Object} The current layout data
         * @throws {Error} If the layout cannot be gathered
         */
        function gatherCurrentLayout() {
            console.log('Gathering current layout data...');
            
            // Get all panels with robust selectors to support different panel implementations
            const panels = document.querySelectorAll('.panel, div[role="region"], .cp-panel');
            console.log('Found panels:', panels.length);
            
            if (panels.length === 0) {
                // We'll add a user-friendly error message here
                showNotification('No panels to export. Add some panels first.', 'warning');
                throw new Error('No panels found to export');
            }
            
            const savedPanels = [];
            
            // Process each panel
            panels.forEach((panel, index) => {
                try {
                    // Use a helper function to extract the panel title with multiple selectors
                    const getTitleText = (panel) => {
                        const selectors = [
                            '.panel-header div',         // Standard selector
                            '.panel-title',              // Accessible version
                            '[role="heading"]',          // ARIA role
                            'h2, h3, h4'                 // Basic headings
                        ];
                        
                        for (const selector of selectors) {
                            const element = panel.querySelector(selector);
                            if (element && element.textContent) {
                                return element.textContent.trim();
                            }
                        }
                        
                        // Fallback to panel ID or default text
                        return panel.id || panel.getAttribute('aria-label') || `Panel ${index + 1}`;
                    };
                    
                    const title = getTitleText(panel);
                    
                    // Carefully extract panel properties with validation
                    const left = panel.style.left || '0px';
                    const top = panel.style.top || '0px';
                    const width = panel.style.width || '400px';
                    const height = panel.style.height || '300px';
                    const zIndex = parseInt(panel.style.zIndex || '0', 10);
                    
                    // Get panel type (for recreation during import)
                    const type = panel.getAttribute('data-panel-type') || 
                                title.toLowerCase().replace(/\s+/g, '-');
                    
                    // Extract any additional data attributes that might be useful
                    const dataAttributes = {};
                    Array.from(panel.attributes)
                        .filter(attr => attr.name.startsWith('data-'))
                        .forEach(attr => {
                            dataAttributes[attr.name.substring(5)] = attr.value;
                        });
                    
                    // More comprehensive panel object
                    savedPanels.push({
                        title: title,
                        type: type,
                        position: {
                            left: left,
                            top: top
                        },
                        size: {
                            width: width,
                            height: height
                        },
                        zIndex: zIndex,
                        data: dataAttributes,
                        id: panel.id || `panel-${Date.now()}-${index}`
                    });
                } catch (panelError) {
                    console.error(`Error processing panel ${index}:`, panelError);
                    // Continue with other panels instead of failing completely
                }
            });
            
            if (savedPanels.length === 0) {
                throw new Error('Failed to process any panels for export');
            }
            
            // Create comprehensive layout object with metadata
            return {
                panels: savedPanels,
                metadata: {
                    timestamp: new Date().toISOString(),
                    appName: 'Cyberpunk GM Screen',
                    version: CURRENT_LAYOUT_VERSION,
                    panelCount: savedPanels.length
                }
            };
        }
        
        /**
         * Exports the current layout to a JSON file
         * Improved implementation with proper error handling and user feedback
         */
        // Version for layout format
        const CURRENT_LAYOUT_VERSION = '1.1';
        
        function exportLayout() {
            console.log('Running exportLayout function');
            
            try {
                // Gather current layout data (separated for better modularity)
                const layoutData = gatherCurrentLayout();
                
                // Serialize to JSON with proper formatting for debugging
                const jsonStr = JSON.stringify(layoutData, null, 2);
                
                // Create a Blob for the file download
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Generate a descriptive filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const filename = `cyberpunk-layout_${timestamp}_v${CURRENT_LAYOUT_VERSION}.json`;
                
                // Create and trigger download link
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = filename;
                downloadLink.style.display = 'none';
                document.body.appendChild(downloadLink);
                
                // Use setTimeout to ensure the link is fully in the DOM
                setTimeout(() => {
                    try {
                        downloadLink.click();
                        console.log('Download triggered successfully');
                        
                        // Clean up resources after download starts
                        setTimeout(() => {
                            document.body.removeChild(downloadLink);
                            URL.revokeObjectURL(url);
                            console.log('Download resources cleaned up');
                        }, 100);
                        
                        // Show success notification
                        showNotification(`Layout with ${layoutData.panels.length} panels exported to ${filename}`, 'success');
                    } catch (clickError) {
                        console.error('Error triggering download:', clickError);
                        showNotification('Error starting download. Check console for details.', 'error');
                    }
                }, 10);
            } catch (error) {
                console.error('Error exporting layout:', error);
                showNotification(`Error exporting layout: ${error.message}`, 'error');
            }
        }
        
        /**
         * Validates a layout object to ensure it has the required structure
         * @param {Object} layoutData - The layout object to validate
         * @returns {Object} Validation result with valid flag and reason if invalid
         */
        function validateLayoutData(layoutData) {
            console.log('Validating layout data...');
            
            // Check if it's a proper object
            if (!layoutData || typeof layoutData !== 'object') {
                return { 
                    valid: false, 
                    reason: 'Layout data is not a valid object' 
                };
            }
            
            // Check for panels array
            if (!layoutData.panels) {
                return { 
                    valid: false, 
                    reason: 'Layout data missing panels array' 
                };
            }
            
            // Verify panels is an array
            if (!Array.isArray(layoutData.panels)) {
                return { 
                    valid: false, 
                    reason: 'Layout panels must be an array' 
                };
            }
            
            // Check if we have at least one panel
            if (layoutData.panels.length === 0) {
                return { 
                    valid: false, 
                    reason: 'Layout contains no panels' 
                };
            }
            
            // Check for version compatibility
            if (layoutData.metadata && layoutData.metadata.version) {
                const importVersion = layoutData.metadata.version;
                // For now we're lenient with version checking, just warn if different
                if (importVersion !== CURRENT_LAYOUT_VERSION) {
                    console.warn(`Layout version mismatch: importing ${importVersion}, current is ${CURRENT_LAYOUT_VERSION}`);
                }
            }
            
            // Validate each panel has minimum required properties
            const invalidPanels = layoutData.panels.filter(panel => {
                // Each panel must have at least a title or type property
                return !panel.title && !panel.type;
            });
            
            if (invalidPanels.length > 0) {
                return { 
                    valid: false, 
                    reason: `${invalidPanels.length} panels are missing required properties (title or type)` 
                };
            }
            
            // Additional security check - limit number of panels
            const MAX_PANELS = 100; // Reasonable limit to prevent DoS
            if (layoutData.panels.length > MAX_PANELS) {
                return { 
                    valid: false, 
                    reason: `Layout contains too many panels (${layoutData.panels.length}, maximum allowed: ${MAX_PANELS})` 
                };
            }
            
            return { valid: true };
        }
        
        /**
         * Restores a layout from validated layout data
         * @param {Object} layoutData - The validated layout data to restore
         * @returns {boolean} Success flag
         */
        function restoreLayout(layoutData) {
            console.log('Restoring layout from imported data...');
            
            try {
                // Clear existing panels
                clearLayout();
                
                let successCount = 0;
                let errorCount = 0;
                
                // Process each panel in the layout
                layoutData.panels.forEach((panel, index) => {
                    try {
                        // Extract needed information with backward compatibility
                        const title = panel.title || '';
                        
                        // Handle both old format (direct properties) and new format (nested objects)
                        const left = panel.position?.left || panel.left || '0px';
                        const top = panel.position?.top || panel.top || '0px';
                        const width = panel.size?.width || panel.width || '400px';
                        const height = panel.size?.height || panel.height || '300px';
                        const zIndex = panel.zIndex || 10 + index;
                        
                        // Determine panel type - handle both formats
                        let type = panel.type;
                        if (!type) {
                            // Legacy format or missing type - derive from title
                            type = title.toLowerCase().replace(/\s+/g, '-');
                        }
                        
                        console.log(`Creating panel: ${title} (${type})`);
                        
                        // Try to create the panel using application's panel creation function
                        let newPanel = null;
                        
                        // Try different panel creation methods that might be available
                        if (typeof window.createAccessiblePanel === 'function') {
                            console.log('Using createAccessiblePanel function');
                            newPanel = window.createAccessiblePanel(type);
                        } 
                        else if (typeof window.createPanel === 'function') {
                            console.log('Using createPanel function');
                            newPanel = window.createPanel(title);
                        }
                        else {
                            console.warn('No panel creation function found');
                            throw new Error('Cannot create panel: no panel creation function available');
                        }
                        
                        // Apply panel properties if created successfully
                        if (newPanel) {
                            // Position and size
                            newPanel.style.left = left;
                            newPanel.style.top = top;
                            newPanel.style.width = width;
                            newPanel.style.height = height;
                            newPanel.style.zIndex = zIndex;
                            
                            // Apply any additional data attributes
                            if (panel.data) {
                                Object.entries(panel.data).forEach(([key, value]) => {
                                    newPanel.setAttribute(`data-${key}`, value);
                                });
                            }
                            
                            // Restore panel ID if it was saved
                            if (panel.id) {
                                newPanel.id = panel.id;
                            }
                            
                            successCount++;
                        } else {
                            throw new Error('Panel creation failed');
                        }
                    } catch (error) {
                        console.error(`Error restoring panel ${index}:`, error);
                        errorCount++;
                        // Continue with next panel instead of failing completely
                    }
                });
                
                // Report results
                if (errorCount > 0) {
                    showNotification(`Layout imported with ${successCount} panels. ${errorCount} panels failed.`, 'info');
                } else {
                    showNotification(`Layout imported successfully with ${successCount} panels`, 'success');
                }
                
                return successCount > 0;
            } catch (error) {
                console.error('Error restoring layout:', error);
                showNotification(`Failed to restore layout: ${error.message}`, 'error');
                return false;
            }
        }
        
        /**
         * Imports a layout from a JSON file with robust validation and error handling
         * Improved implementation based on recommended practices
         */
        function importLayout() {
            console.log('Running importLayout function');
            
            try {
                // Create a file input element
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                
                // Add change event to handle file selection
                fileInput.addEventListener('change', function(e) {
                    console.log('File selected for import');
                    
                    const file = e.target.files[0];
                    if (!file) {
                        console.log('No file selected');
                        return;
                    }
                    
                    // Create a reader to parse the file
                    const reader = new FileReader();
                    
                    reader.addEventListener('load', function(e) {
                        try {
                            console.log('File loaded, parsing JSON...');
                            
                            // Parse the JSON data
                            let layoutData;
                            try {
                                layoutData = JSON.parse(e.target.result);
                            } catch (parseError) {
                                throw new Error(`Invalid JSON format: ${parseError.message}`);
                            }
                            
                            // Validate the layout structure
                            const validation = validateLayoutData(layoutData);
                            if (!validation.valid) {
                                throw new Error(`Invalid layout format: ${validation.reason}`);
                            }
                            
                            console.log('Layout validated successfully:', layoutData);
                            
                            // Confirm before replacing current layout
                            if (confirm(`Import layout with ${layoutData.panels.length} panels? Current layout will be replaced.`)) {
                                // Restore the layout from validated data
                                restoreLayout(layoutData);
                                
                                // Store in localStorage for auto-save if enabled
                                if (localStorage.getItem('autosave-enabled') !== 'false') {
                                    try {
                                        localStorage.setItem('cyberpunk-layout-autosave', JSON.stringify(layoutData));
                                        console.log('Imported layout saved to localStorage');
                                    } catch (storageError) {
                                        console.warn('Failed to save imported layout to localStorage:', storageError);
                                    }
                                }
                            } else {
                                console.log('User cancelled layout import');
                            }
                        } catch (error) {
                            console.error('Error importing layout:', error);
                            showNotification(`Error importing layout: ${error.message}`, 'error');
                        }
                    });
                    
                    // Handle file reading errors
                    reader.addEventListener('error', function(error) {
                        console.error('Error reading file:', error);
                        showNotification('Error reading file. Check console for details.', 'error');
                    });
                    
                    // Start reading the file
                    reader.readAsText(file);
                });
                
                // Add the file input to the DOM and trigger the file selector
                document.body.appendChild(fileInput);
                fileInput.click();
                
                // Clean up the file input element after a delay
                setTimeout(() => {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                        console.log('File input element cleaned up');
                    }
                }, 5000);
            } catch (error) {
                console.error('Error setting up import:', error);
                showNotification(`Error setting up import: ${error.message}`, 'error');
            }
        }

        // Helper function for showing notifications
        function showNotification(message, type = 'success', duration = 3000) {
            // Find or create notification container
            let container = document.querySelector('.cp-notifications');
            if (!container) {
                container = document.createElement('div');
                container.className = 'cp-notifications';
                container.setAttribute('aria-live', 'polite');
                document.body.appendChild(container);
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `cp-notification cp-notification-${type}`;
            notification.textContent = message;
            
            // Add to container
            container.appendChild(notification);
            
            // Remove after duration
            setTimeout(() => {
                notification.classList.add('cp-notification-hiding');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }
    </script>
    
    <script>
        // Define local functions for use by event handlers - these will be accessible from the event listeners
        function clearLayout() {
            console.log('Running local clearLayout function');
            
            // Get all panels and remove them
            const panels = document.querySelectorAll('.panel, div[role="region"]');
            
            if (panels.length > 0) {
                if (confirm('Are you sure you want to remove all panels?')) {
                    panels.forEach(panel => panel.remove());
                    showNotification('All panels removed', 'success');
                    return true;
                }
            } else {
                showNotification('No panels to clear', 'info');
            }
            return false;
        }
        
        function autoOrganizePanels() {
            console.log('Running local autoOrganizePanels function');
            
            // Get all panels
            const panels = document.querySelectorAll('.panel, div[role="region"]');
            if (panels.length === 0) {
                showNotification('No panels to organize', 'info');
                return;
            }
            
            // Calculate grid dimensions
            const count = panels.length;
            const columns = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / columns);
            
            // Get viewport dimensions
            const toolbar = document.querySelector('.toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight - toolbarHeight - 40;
            
            // Calculate panel dimensions
            const panelWidth = Math.floor(viewportWidth / columns) - 20;
            const panelHeight = Math.floor(viewportHeight / rows) - 20;
            
            // Position panels
            panels.forEach((panel, index) => {
                const row = Math.floor(index / columns);
                const col = index % columns;
                
                panel.style.left = (col * (panelWidth + 20) + 10) + 'px';
                panel.style.top = (toolbarHeight + row * (panelHeight + 20) + 10) + 'px';
                panel.style.width = panelWidth + 'px';
                panel.style.height = panelHeight + 'px';
            });
            
            showNotification('Panels organized in grid layout', 'success');
        }
        
        function fitPanelsToWindow() {
            console.log('Running local fitPanelsToWindow function');
            
            // Get all panels
            const panels = document.querySelectorAll('.panel, div[role="region"]');
            if (panels.length === 0) {
                showNotification('No panels to fit', 'info');
                return;
            }
            
            // Get viewport dimensions
            const toolbar = document.querySelector('.toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight - toolbarHeight - 40;
            
            // Group panels by type using data-panel attribute
            const types = {};
            panels.forEach(panel => {
                const type = panel.getAttribute('data-panel') || 'unknown';
                if (!types[type]) types[type] = [];
                types[type].push(panel);
            });
            
            const typeCount = Object.keys(types).length;
            let rows, cols;
            
            // Calculate grid based on type count
            if (typeCount <= 2) {
                rows = 1;
                cols = typeCount;
            } else if (typeCount <= 6) {
                rows = 2;
                cols = Math.ceil(typeCount / 2);
            } else {
                rows = 3;
                cols = Math.ceil(typeCount / 3);
            }
            
            // Calculate cell dimensions
            const cellWidth = Math.floor(viewportWidth / cols);
            const cellHeight = Math.floor(viewportHeight / rows);
            
            // Position panels by type
            let typeIndex = 0;
            for (const type in types) {
                const row = Math.floor(typeIndex / cols);
                const col = typeIndex % cols;
                const typePanels = types[type];
                
                if (typePanels.length === 1) {
                    // Single panel of this type
                    const panel = typePanels[0];
                    panel.style.left = (col * cellWidth + 10) + 'px';
                    panel.style.top = (toolbarHeight + row * cellHeight + 10) + 'px';
                    panel.style.width = (cellWidth - 20) + 'px';
                    panel.style.height = (cellHeight - 20) + 'px';
                } else {
                    // Multiple panels of this type
                    const subCols = Math.ceil(Math.sqrt(typePanels.length));
                    const subRows = Math.ceil(typePanels.length / subCols);
                    
                    const subWidth = cellWidth / subCols;
                    const subHeight = cellHeight / subRows;
                    
                    typePanels.forEach((panel, i) => {
                        const subRow = Math.floor(i / subCols);
                        const subCol = i % subCols;
                        
                        panel.style.left = (col * cellWidth + subCol * subWidth + 5) + 'px';
                        panel.style.top = (toolbarHeight + row * cellHeight + subRow * subHeight + 5) + 'px';
                        panel.style.width = (subWidth - 10) + 'px';
                        panel.style.height = (subHeight - 10) + 'px';
                    });
                }
                
                typeIndex++;
            }
            
            showNotification('Panels fitted to window by type', 'success');
        }

        // Font Settings System
        // Global settings object to store user preferences
        let userSettings = {
            fontSize: 16,
            fontFamily: "monospace, 'Consolas', 'Courier New'",  // Direct font family instead of CSS variable
            savedFonts: []
        };

        // Function to toggle font settings panel visibility
        function toggleFontSettings() {
            const fontPanel = document.querySelector('.font-settings-panel');
            if (fontPanel) {
                console.log('Toggling font settings panel visibility');
                const isVisible = fontPanel.classList.toggle('active');
                
                // If making visible, update the preview
                if (isVisible) {
                    console.log('Font settings panel is now visible');
                    updateFontPreview();
                } else {
                    console.log('Font settings panel is now hidden');
                }
            } else {
                console.error('Font settings panel not found with class: font-settings-panel');
            }
        }

        // Function to apply font settings to all panels
        function applyFontSettings() {
            const previewText = document.getElementById('font-preview-text');
            
            console.log('Applying font settings:', userSettings);
            
            // Create or update a style element to apply font settings globally to panel content
            let styleElement = document.getElementById('panel-font-styles');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'panel-font-styles';
                document.head.appendChild(styleElement);
            }
            
            // Define a comprehensive CSS rule that targets only content (not headers)
            const cssRules = `
                /* Apply font settings to all panel content but not headers */
                .panel-content, 
                .panel-content div:not(.panel-header),
                .panel-content p, 
                .panel-content span,
                .panel-content li,
                .panel-content td,
                .panel-content th,
                .panel-content ul,
                .panel-content ol,
                .dice-result,
                .text-content,
                textarea {
                    font-family: ${userSettings.fontFamily} !important;
                    font-size: ${userSettings.fontSize}px !important;
                }
                
                /* Make sure we don't affect panel headers */
                .panel-header,
                .panel-header *,
                .panel-title,
                .close-button {
                    font-family: 'Display', 'VeniteAdoremus', serif !important;
                }
            `;
            
            styleElement.innerHTML = cssRules;
            console.log('Added CSS rules for font settings:', cssRules);
            
            // Also directly apply to panel content elements for immediate feedback
            // Target only panel content, not headers
            const panelContents = document.querySelectorAll('.panel-content');
            console.log('Found panel content elements:', panelContents.length);
            
            panelContents.forEach(content => {
                content.style.fontSize = userSettings.fontSize + 'px';
                content.style.fontFamily = userSettings.fontFamily;
                console.log('Applied to panel content:', content);
            });
            
            // Target textareas specifically (for notes panels)
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                textarea.style.fontSize = userSettings.fontSize + 'px';
                textarea.style.fontFamily = userSettings.fontFamily;
                console.log('Applied to textarea:', textarea);
            });
            
            // Apply to preview text
            if (previewText) {
                previewText.style.fontSize = userSettings.fontSize + 'px';
                previewText.style.fontFamily = userSettings.fontFamily;
            }
            
            // Add font injector div to force browser to load fonts
            let fontInjector = document.getElementById('font-injector');
            if (!fontInjector) {
                fontInjector = document.createElement('div');
                fontInjector.id = 'font-injector';
                fontInjector.style.position = 'absolute';
                fontInjector.style.left = '-9999px';
                fontInjector.style.visibility = 'hidden';
                document.body.appendChild(fontInjector);
            }
            
            // Force font loading by creating samples of each font
            fontInjector.innerHTML = `
                <span style="font-family: monospace, 'Consolas', 'Courier New'">Font Mono Test</span>
                <span style="font-family: 'Segoe UI', 'Roboto', sans-serif">Font Primary Test</span>
                <span style="font-family: 'Display', 'VeniteAdoremus', serif">Font Display Test</span>
                <span style="font-family: 'Cyberpunk', 'BladeRunner', sans-serif">Cyberpunk Font Test</span>
            `;
            
            // Save the settings
            saveSettings();
            
            // Show notification
            showNotification('Font settings applied', 'success');
        }

        // Function to save current font settings as a preset
        function saveFontSettings() {
            try {
                // Create a new font setting
                const fontSetting = {
                    name: `Font Setting ${userSettings.savedFonts ? userSettings.savedFonts.length + 1 : 1}`,
                    fontSize: userSettings.fontSize,
                    fontFamily: userSettings.fontFamily,
                    timestamp: new Date().toISOString()
                };

                // Initialize the savedFonts array if it doesn't exist
                if (!userSettings.savedFonts) {
                    userSettings.savedFonts = [];
                }

                // Add to saved fonts
                userSettings.savedFonts.push(fontSetting);
                
                console.log('Saving font setting:', fontSetting);
                console.log('Updated savedFonts:', userSettings.savedFonts);
                
                // Save to localStorage
                saveSettings();
                
                showNotification('Font settings saved as preset', 'success');
            } catch (error) {
                console.error("Error saving font settings:", error);
                showNotification('Error saving font settings', 'error');
            }
        }
        
        // Function to load font settings from saved preset
        function loadFontSettings() {
            try {
                console.log('Loading font settings, current state:', userSettings);
                
                // Check if we have any saved font settings
                if (!userSettings.savedFonts || userSettings.savedFonts.length === 0) {
                    console.log('No saved font settings found');
                    showNotification('No saved font settings found', 'info');
                    return;
                }
                
                // Get the most recent saved setting
                const savedSetting = userSettings.savedFonts[
                    userSettings.savedFonts.length - 1
                ];
                console.log('Loading saved font setting:', savedSetting);
                
                // Apply the saved settings
                userSettings.fontSize = savedSetting.fontSize;
                userSettings.fontFamily = savedSetting.fontFamily;
                console.log('Applied saved settings to userSettings', userSettings);
                
                // Update UI to reflect the loaded settings
                updateFontSettingsUI();
                
                // Apply the settings
                applyFontSettings();
                
                showNotification('Font settings loaded from preset', 'success');
            } catch (error) {
                console.error("Error loading font settings:", error);
                showNotification('Error loading font settings', 'error');
            }
        }
        
        // Function to reset font settings to defaults
        function resetFontSettings() {
            if (confirm("Reset font settings to defaults?")) {
                // Set default values
                userSettings.fontSize = 16;
                userSettings.fontFamily = "monospace, 'Consolas', 'Courier New'";  // Direct font family
                
                // Update UI
                updateFontSettingsUI();
                
                // Apply settings
                applyFontSettings();
                
                showNotification('Font settings reset to defaults', 'info');
            }
        }
        
        // Function to update the UI to reflect current font settings
        function updateFontSettingsUI() {
            // Update font size buttons
            document.querySelectorAll('.font-size-btn').forEach(btn => {
                const size = parseInt(btn.getAttribute('data-size'));
                const isActive = size === userSettings.fontSize;
                
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-checked', isActive ? 'true' : 'false');
            });
            
            // Update font family select
            const fontSelect = document.getElementById('font-family');
            if (fontSelect) {
                if (fontSelect.value !== userSettings.fontFamily) {
                    console.log('Updating font family select to:', userSettings.fontFamily);
                    // Try to find the option with this value
                    let found = false;
                    for (let i = 0; i < fontSelect.options.length; i++) {
                        if (fontSelect.options[i].value === userSettings.fontFamily) {
                            fontSelect.selectedIndex = i;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        console.warn('Could not find font family option with value:', userSettings.fontFamily);
                        fontSelect.value = userSettings.fontFamily;
                    }
                }
            }
            
            // Update preview text
            updateFontPreview();
        }
        
        // Function to update the font preview
        function updateFontPreview() {
            const previewText = document.getElementById('font-preview-text');
            if (previewText) {
                console.log('Updating font preview with:', userSettings.fontSize + 'px', userSettings.fontFamily);
                previewText.style.fontSize = userSettings.fontSize + 'px';
                previewText.style.fontFamily = userSettings.fontFamily;
                
                // Let's be extra certain by setting it with !important
                previewText.setAttribute('style', 
                    `font-size: ${userSettings.fontSize}px !important; 
                     font-family: ${userSettings.fontFamily} !important;`
                );
                
                // Validate what was applied
                const computedStyle = window.getComputedStyle(previewText);
                console.log('Computed style after update:', 
                    computedStyle.getPropertyValue('font-size'),
                    computedStyle.getPropertyValue('font-family')
                );
            } else {
                console.error('Preview text element not found with ID: font-preview-text');
            }
        }
        
        // Function to save settings to localStorage
        function saveSettings() {
            try {
                console.log('Saving settings to localStorage:', userSettings);
                localStorage.setItem('cyberpunk-gm-settings', JSON.stringify(userSettings));
            } catch (error) {
                console.error('Error saving settings to localStorage:', error);
            }
        }
        
        // Function to load settings from localStorage
        function loadSettings() {
            try {
                console.log('Loading settings from localStorage');
                const saved = localStorage.getItem('cyberpunk-gm-settings');
                if (saved) {
                    console.log('Found saved settings:', saved);
                    const parsed = JSON.parse(saved);
                    console.log('Parsed settings:', parsed);
                    
                    // Merge saved settings with defaults
                    userSettings = {...userSettings, ...parsed};
                    console.log('Merged settings:', userSettings);
                    
                    // Update UI if font settings panel exists
                    if (document.querySelector('.font-settings-panel')) {
                        console.log('Updating font settings UI');
                        updateFontSettingsUI();
                    }
                } else {
                    console.log('No saved settings found in localStorage');
                }
            } catch (error) {
                console.error('Error loading settings from localStorage:', error);
            }
        }
        
        // Function to set up font controls event handlers
        function setupFontControls() {
            // Show font settings button
            const showFontSettingsBtn = document.getElementById('show-font-settings');
            if (showFontSettingsBtn) {
                showFontSettingsBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    toggleFontSettings();
                });
            }
            
            // Close font settings button
            const closeFontControlsBtn = document.getElementById('close-font-controls');
            if (closeFontControlsBtn) {
                closeFontControlsBtn.addEventListener('click', function() {
                    toggleFontSettings();
                });
            }
            
            // Font size buttons
            document.querySelectorAll('.font-size-btn').forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.font-size-btn').forEach(btn => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-checked', 'false');
                    });
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    this.setAttribute('aria-checked', 'true');
                    
                    // Update font size setting
                    userSettings.fontSize = parseInt(this.getAttribute('data-size'));
                    
                    // Update preview
                    updateFontPreview();
                });
            });
            
            // Font family select - add a direct test
            console.log('Looking for font-family select element:');
            console.log('By ID:', document.getElementById('font-family'));
            console.log('By name:', document.querySelector('select[name="font-family"]'));
            console.log('By query all selects:', document.querySelectorAll('select'));
            
            // Font family select - try all methods to find it
            const fontFamilySelect = document.getElementById('font-family') || 
                                 document.querySelector('select[name="font-family"]') ||
                                 document.querySelector('.font-options select');
                                 
            if (fontFamilySelect) {
                console.log('Found font family select:', fontFamilySelect);
                
                // Check initial value
                console.log('Initial font family select value:', fontFamilySelect.value);
                
                // Check options
                console.log('Font family select options:');
                Array.from(fontFamilySelect.options).forEach((option, index) => {
                    console.log(`Option ${index}:`, option.value, option.text);
                });
                
                // Add event listener
                fontFamilySelect.addEventListener('change', function(e) {
                    console.log('Font family select changed event:', e);
                    console.log('New value:', this.value);
                    console.log('Selected option text:', this.options[this.selectedIndex].text);
                    
                    userSettings.fontFamily = this.value;
                    
                    // Update preview immediately
                    updateFontPreview();
                    
                    // Apply immediately to see changes
                    applyFontSettings();
                });
                
                // Also try adding an onchange property
                fontFamilySelect.onchange = function() {
                    console.log('Font family onchange triggered with value:', this.value);
                    userSettings.fontFamily = this.value;
                    updateFontPreview();
                    applyFontSettings();
                };
            } else {
                console.error('CRITICAL: Font family select not found with any selector!');
            }
            
            // Apply font button
            const applyFontBtn = document.getElementById('apply-font');
            if (applyFontBtn) {
                applyFontBtn.addEventListener('click', function() {
                    applyFontSettings();
                });
            }
            
            // Save font button
            const saveFontBtn = document.getElementById('save-font');
            if (saveFontBtn) {
                saveFontBtn.addEventListener('click', function() {
                    saveFontSettings();
                });
            }
            
            // Load font button
            const loadFontBtn = document.getElementById('load-font');
            if (loadFontBtn) {
                loadFontBtn.addEventListener('click', function() {
                    loadFontSettings();
                });
            }
            
            // Reset font button
            const resetFontBtn = document.getElementById('reset-font');
            if (resetFontBtn) {
                resetFontBtn.addEventListener('click', function() {
                    resetFontSettings();
                });
            }
            
            // Initialize preview with current settings
            updateFontPreview();
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Check if layout module is available
            if (window.CyberpunkGM && window.CyberpunkGM.Layout) {
                console.log('CyberpunkGM.Layout module loaded successfully with functions:', 
                    Object.keys(window.CyberpunkGM.Layout));
            } else {
                console.warn('CyberpunkGM.Layout module not available, will use fallback functions');
            }
            
            // Make sure the adapter script has loaded completely
            
            // Define a function to set up all layout menu event listeners
            function setupLayoutMenuEventListeners() {
                console.log('Setting up layout menu event listeners...');
                
                // Helper function to safely attach event listeners
                function safeAddEventListener(id, eventType, handler) {
                    const element = document.getElementById(id);
                    if (element) {
                        console.log(`Found element with id "${id}", attaching ${eventType} listener`);
                        element.addEventListener(eventType, handler);
                        return true;
                    } else {
                        console.error(`Element with id "${id}" not found!`);
                        return false;
                    }
                }
                
                // Clear Layout
                safeAddEventListener('clear-layout', 'click', function(e) {
                    e.preventDefault();
                    console.log('Clear Layout button clicked');
                    
                    try {
                        // Try local function first
                        if (typeof clearLayout === 'function') {
                            console.log('Using local clearLayout function');
                            clearLayout();
                        }
                        // First try window.clearLayout function
                        else if (typeof window.clearLayout === 'function') {
                            console.log('Using window.clearLayout function');
                            window.clearLayout();
                        }
                        // Then try CyberpunkGM.Layout.clearLayout
                        else if (window.CyberpunkGM && window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.clearLayout === 'function') {
                            console.log('Using CyberpunkGM.Layout.clearLayout function');
                            window.CyberpunkGM.Layout.clearLayout();
                        }
                        // Fallback to simple DOM clearing
                        else {
                            console.log('No clearLayout function found, using inline implementation');
                            // Get all panels and remove them
                            const panels = document.querySelectorAll('.panel, div[role="region"]');
                            
                            if (panels.length > 0) {
                                if (confirm('Are you sure you want to remove all panels?')) {
                                    panels.forEach(panel => panel.remove());
                                    showNotification('All panels removed', 'success');
                                }
                            } else {
                                showNotification('No panels to clear', 'info');
                            }
                        }
                    } catch (error) {
                        console.error('Error clearing layout:', error);
                        showNotification('Error clearing layout: ' + error.message, 'error');
                    }
                });
                
                // Auto-Organize
                safeAddEventListener('auto-organize', 'click', function(e) {
                    e.preventDefault();
                    console.log('Auto-Organize button clicked');
                    
                    try {
                        // Look for our globally defined function - make sure it's available first
                        // by checking if it's been called yet
                        if (typeof autoOrganizePanels === 'function') {
                            console.log('Using local autoOrganizePanels function');
                            autoOrganizePanels();
                        }
                        // Try window.autoOrganizePanels function
                        else if (typeof window.autoOrganizePanels === 'function') {
                            console.log('Using window.autoOrganizePanels function');
                            window.autoOrganizePanels();
                        }
                        // Then try CyberpunkGM.Layout.autoOrganize
                        else if (window.CyberpunkGM && window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.autoOrganize === 'function') {
                            console.log('Using CyberpunkGM.Layout.autoOrganize function');
                            window.CyberpunkGM.Layout.autoOrganize();
                        }
                        // Implement a basic version right here as last resort
                        else {
                            console.log('No autoOrganizePanels function found, using inline implementation');
                            
                            // Basic implementation inline
                            const panels = document.querySelectorAll('.panel, div[role="region"]');
                            if (panels.length === 0) {
                                showNotification('No panels to organize', 'info');
                                return;
                            }
                            
                            // Calculate grid dimensions
                            const count = panels.length;
                            const columns = Math.ceil(Math.sqrt(count));
                            const rows = Math.ceil(count / columns);
                            
                            // Get viewport dimensions
                            const toolbar = document.querySelector('.toolbar');
                            const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
                            const viewportWidth = window.innerWidth;
                            const viewportHeight = window.innerHeight - toolbarHeight - 40;
                            
                            // Calculate panel dimensions
                            const panelWidth = Math.floor(viewportWidth / columns) - 20;
                            const panelHeight = Math.floor(viewportHeight / rows) - 20;
                            
                            // Position panels
                            panels.forEach((panel, index) => {
                                const row = Math.floor(index / columns);
                                const col = index % columns;
                                
                                panel.style.left = (col * (panelWidth + 20) + 10) + 'px';
                                panel.style.top = (toolbarHeight + row * (panelHeight + 20) + 10) + 'px';
                                panel.style.width = panelWidth + 'px';
                                panel.style.height = panelHeight + 'px';
                            });
                            
                            showNotification('Panels organized in grid layout', 'success');
                        }
                    } catch (error) {
                        console.error('Error auto-organizing panels:', error);
                        showNotification('Error auto-organizing panels: ' + error.message, 'error');
                    }
                });
                
                // Fit to Window
                safeAddEventListener('fit-to-window', 'click', function(e) {
                    e.preventDefault();
                    console.log('Fit to Window button clicked');
                    
                    try {
                        // Look for our locally defined function first
                        if (typeof fitPanelsToWindow === 'function') {
                            console.log('Using local fitPanelsToWindow function');
                            fitPanelsToWindow();
                        }
                        // Then try window.fitPanelsToWindow function
                        else if (typeof window.fitPanelsToWindow === 'function') {
                            console.log('Using window.fitPanelsToWindow function');
                            window.fitPanelsToWindow();
                        }
                        // Then try CyberpunkGM.Layout.fitToWindow
                        else if (window.CyberpunkGM && window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.fitToWindow === 'function') {
                            console.log('Using CyberpunkGM.Layout.fitToWindow function');
                            window.CyberpunkGM.Layout.fitToWindow();
                        }
                        // Implement a basic version right here as last resort
                        else {
                            console.log('No fitPanelsToWindow function found, using inline implementation');
                            
                            // Basic implementation
                            const panels = document.querySelectorAll('.panel, div[role="region"]');
                            if (panels.length === 0) {
                                showNotification('No panels to fit', 'info');
                                return;
                            }
                            
                            // Get viewport dimensions
                            const toolbar = document.querySelector('.toolbar');
                            const toolbarHeight = toolbar ? toolbar.offsetHeight : 60;
                            const viewportWidth = window.innerWidth;
                            const viewportHeight = window.innerHeight - toolbarHeight - 40;
                            
                            // Group panels by type using data-panel attribute
                            const types = {};
                            panels.forEach(panel => {
                                const type = panel.getAttribute('data-panel') || 'unknown';
                                if (!types[type]) types[type] = [];
                                types[type].push(panel);
                            });
                            
                            const typeCount = Object.keys(types).length;
                            let rows, cols;
                            
                            // Calculate grid based on type count
                            if (typeCount <= 2) {
                                rows = 1;
                                cols = typeCount;
                            } else if (typeCount <= 6) {
                                rows = 2;
                                cols = Math.ceil(typeCount / 2);
                            } else {
                                rows = 3;
                                cols = Math.ceil(typeCount / 3);
                            }
                            
                            // Calculate cell dimensions
                            const cellWidth = Math.floor(viewportWidth / cols);
                            const cellHeight = Math.floor(viewportHeight / rows);
                            
                            // Position panels by type
                            let typeIndex = 0;
                            for (const type in types) {
                                const row = Math.floor(typeIndex / cols);
                                const col = typeIndex % cols;
                                const typePanels = types[type];
                                
                                if (typePanels.length === 1) {
                                    // Single panel of this type
                                    const panel = typePanels[0];
                                    panel.style.left = (col * cellWidth + 10) + 'px';
                                    panel.style.top = (toolbarHeight + row * cellHeight + 10) + 'px';
                                    panel.style.width = (cellWidth - 20) + 'px';
                                    panel.style.height = (cellHeight - 20) + 'px';
                                } else {
                                    // Multiple panels of this type
                                    const subCols = Math.ceil(Math.sqrt(typePanels.length));
                                    const subRows = Math.ceil(typePanels.length / subCols);
                                    
                                    const subWidth = cellWidth / subCols;
                                    const subHeight = cellHeight / subRows;
                                    
                                    typePanels.forEach((panel, i) => {
                                        const subRow = Math.floor(i / subCols);
                                        const subCol = i % subCols;
                                        
                                        panel.style.left = (col * cellWidth + subCol * subWidth + 5) + 'px';
                                        panel.style.top = (toolbarHeight + row * cellHeight + subRow * subHeight + 5) + 'px';
                                        panel.style.width = (subWidth - 10) + 'px';
                                        panel.style.height = (subHeight - 10) + 'px';
                                    });
                                }
                                
                                typeIndex++;
                            }
                            
                            showNotification('Panels fitted to window by type', 'success');
                        }
                    } catch (error) {
                        console.error('Error fitting panels to window:', error);
                        showNotification('Error fitting panels to window: ' + error.message, 'error');
                    }
                });
                
                // Export Layout
                safeAddEventListener('app-export-layout', 'click', function(e) {
                    e.preventDefault();
                    console.log('Export Layout button clicked');
                    
                    try {
                        // First check if the Layout module exists and has exportLayout
                        if (window.CyberpunkGM && 
                            window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.exportLayout === 'function') {
                                
                            console.log('Using CyberpunkGM.Layout.exportLayout');
                            // Directly call the Layout module's export function
                            window.CyberpunkGM.Layout.exportLayout();
                        } else {
                            console.log('Using fallback exportLayout');
                            
                            // Call our custom implementation instead
                            exportLayout();
                        }
                    } catch (error) {
                        console.error('Error in export layout handler:', error);
                        showNotification('Error exporting layout: ' + error.message, 'error');
                    }
                });
                
                // Import Layout
                safeAddEventListener('app-import-layout', 'click', function(e) {
                    e.preventDefault();
                    console.log('Import Layout button clicked');
                    
                    try {
                        // First check if the Layout module exists and has importLayout
                        if (window.CyberpunkGM && 
                            window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.importLayout === 'function') {
                                
                            console.log('Using CyberpunkGM.Layout.importLayout');
                            // Directly call the Layout module's import function
                            window.CyberpunkGM.Layout.importLayout();
                        } else {
                            console.log('Using fallback importLayout');
                            
                            // Call our custom implementation instead
                            importLayout();
                        }
                    } catch (error) {
                        console.error('Error in import layout handler:', error);
                        showNotification('Error importing layout: ' + error.message, 'error');
                    }
                });
                
                // Toggle Auto-Save
                safeAddEventListener('app-toggle-autosave', 'click', function(e) {
                    e.preventDefault();
                    console.log('Toggle Auto-Save button clicked');
                    
                    try {
                        // If we have the Layout module, use its auto-save functionality
                        if (window.CyberpunkGM && 
                            window.CyberpunkGM.Layout && 
                            typeof window.CyberpunkGM.Layout.setAutoSaveEnabled === 'function') {
                                
                            console.log('Using CyberpunkGM.Layout for auto-save toggle');
                            
                            // Get the current auto-save state using the standard key
                            const storageKey = 'cyberpunk-autosave-enabled';
                            const isEnabled = localStorage.getItem(storageKey) !== 'false';
                            
                            // Toggle the setting using the layout module
                            window.CyberpunkGM.Layout.setAutoSaveEnabled(!isEnabled);
                            
                            // Update the button text
                            this.textContent = !isEnabled ? 'Auto-Save: On' : 'Auto-Save: Off';
                            
                            // Show notification
                            showNotification(`Auto-save ${!isEnabled ? 'enabled' : 'disabled'}`, 'success');
                        } else {
                            console.log('Using fallback auto-save toggle');
                            
                            // Simple fallback implementation without the module
                            const storageKey = 'cyberpunk-autosave-enabled'; // Use standard key for compatibility
                            const isEnabled = localStorage.getItem(storageKey) !== 'false';
                            
                            // Toggle the setting
                            localStorage.setItem(storageKey, !isEnabled);
                            
                            // Update the button text
                            this.textContent = !isEnabled ? 'Auto-Save: On' : 'Auto-Save: Off';
                            
                            // Show notification
                            showNotification(`Auto-save ${!isEnabled ? 'enabled' : 'disabled'}`, 'success');
                        }
                    } catch (error) {
                        console.error('Error in toggle auto-save handler:', error);
                        showNotification('Error toggling auto-save: ' + error.message, 'error');
                    }
                });
                
                console.log('Layout menu event listeners setup complete');
            }
            
            // Call the function to set up event listeners right away
            setupLayoutMenuEventListeners();
            
            // Set up a backup timeout to ensure event listeners are set up even if there are timing issues
            setTimeout(function() {
                console.log('Running backup event listener setup...');
                setupLayoutMenuEventListeners();
            }, 1000);
            
            // Enhance dropdown menu button behavior to ensure they stay above panels
            document.querySelectorAll('.dropdown button').forEach(button => {
                // Add enhanced click handling
                button.addEventListener('click', function(e) {
                    e.preventDefault(); 
                    
                    // Force any open dropdown to close
                    document.querySelectorAll('.dropdown-content.active').forEach(content => {
                        if (content !== this.nextElementSibling) {
                            content.classList.remove('active');
                        }
                    });
                    
                    // Toggle this dropdown
                    const dropdown = this.closest('.dropdown');
                    const content = dropdown.querySelector('.dropdown-content');
                    
                    // Toggle aria expanded state
                    const isExpanded = this.getAttribute('aria-expanded') === 'true';
                    this.setAttribute('aria-expanded', !isExpanded);
                    
                    // Toggle active state - force showing with our enhanced CSS
                    content.classList.toggle('active');
                    
                    console.log('Dropdown clicked, active state:', content.classList.contains('active'));
                });
            });
            
            // Add document click handler to close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                // If the click is outside all dropdown menus and buttons
                if (!e.target.closest('.dropdown')) {
                    // Close all active dropdowns
                    document.querySelectorAll('.dropdown-content.active').forEach(content => {
                        content.classList.remove('active');
                        
                        // Update aria-expanded state on the parent button
                        const button = content.parentElement.querySelector('button');
                        if (button) {
                            button.setAttribute('aria-expanded', 'false');
                        }
                    });
                }
            });
            
            // Trigger the custom event to ensure layout functionality is loaded properly
            if (document.createEvent) {
                const readyEvent = document.createEvent('Event');
                readyEvent.initEvent('cyberpunk-app-ready', true, true);
                document.dispatchEvent(readyEvent);
                console.log('🔍 Triggered cyberpunk-app-ready event for layout system');
                
                // Log that layout functions are initialized
                console.log('📱 Layout functions initialized:');
                console.log('  - clearLayout', typeof window.clearLayout === 'function' ? '✅' : '❌');
                console.log('  - autoOrganizePanels', typeof window.autoOrganizePanels === 'function' ? '✅' : '❌');
                console.log('  - fitPanelsToWindow', typeof window.fitPanelsToWindow === 'function' ? '✅' : '❌');
                
                // Check if the layout module is properly initialized
                setTimeout(() => {
                    if (window.CyberpunkGM && window.CyberpunkGM.Layout) {
                        console.log('✅ Layout system successfully initialized:', Object.keys(window.CyberpunkGM.Layout));
                    } else {
                        console.error('❌ Layout system not properly initialized');
                    }
                }, 1000);
                
                // Add a test handler for the layout system test button
                document.getElementById('test-layout').addEventListener('click', function(e) {
                    e.preventDefault();
                    if (window.CyberpunkGM && window.CyberpunkGM.Layout) {
                        console.log('Testing layout system...');
                        // Try saving the current layout
                        const layout = window.CyberpunkGM.Layout.saveLayout('test');
                        console.log('Current layout:', layout);
                        alert('Layout system test complete - check console for results');
                    } else {
                        console.error('Layout system not available');
                        alert('Layout system not available');
                    }
                });
            }
            if (typeof window.createAccessiblePanel !== 'function') {
                console.error('createAccessiblePanel function not available. Make sure app-modern-adapter-fixed.js is loaded correctly.');
                alert('Error: Panel system not loaded correctly. Please check the console for details.');
                return;
            }
            
            // Initialize accessibility for elements
            initAccessibility();
            
            // Preload fonts
            function preloadFonts() {
                console.log('Preloading fonts...');
                const fontFamilies = [
                    "monospace, 'Consolas', 'Courier New'",
                    "'Segoe UI', 'Roboto', sans-serif",
                    "'Display', 'VeniteAdoremus', serif",
                    "'Cyberpunk', 'BladeRunner', sans-serif"
                ];
                
                // Create a temporary div to force font loading
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.visibility = 'hidden';
                
                // Create spans with each font
                fontFamilies.forEach(fontFamily => {
                    const span = document.createElement('span');
                    span.style.fontFamily = fontFamily;
                    span.textContent = 'Font Preload Test';
                    tempDiv.appendChild(span);
                });
                
                document.body.appendChild(tempDiv);
                
                // Clean up after a delay to ensure fonts are loaded
                setTimeout(() => {
                    document.body.removeChild(tempDiv);
                    console.log('Font preloading complete');
                }, 1000);
            }
            
            // Preload fonts before initializing settings
            preloadFonts();
            
            // Initialize font settings
            loadSettings();
            setupFontControls();
            
            // Create a welcome panel
            setTimeout(function() {
                // Create initial notes panel with instructions
                const welcomePanel = window.createAccessiblePanel('notes', {
                    x: 50,
                    y: 100,
                    width: 450,
                    height: 350
                });
                
                // Show welcome notification
                window.showNotification('Welcome to the Cyberpunk RED GM Screen! Click "Add Panel" to get started.', 'info', 5000);
                
                // Set welcome text if panel was created successfully
                if (welcomePanel) {
                    setTimeout(function() {
                        const panel = document.querySelector(`.panel[data-id="${welcomePanel}"]`);
                        if (panel) {
                            const textarea = panel.querySelector('textarea');
                            if (textarea) {
                                textarea.value = "Welcome to your Cyberpunk RED GM Screen!\n\n" +
                                    "• Add panels using the dropdown menu above\n" +
                                    "• Drag panels by their headers to position them\n" +
                                    "• Resize panels using the bottom-right corner handle\n" +
                                    "• Save your layout using the Layout menu\n" +
                                    "• Navigate with keyboard using Tab and arrow keys\n" +
                                    "• Press ESC to close a dropdown menu\n\n" +
                                    "Ready to run the streets of Night City, choomba!";
                            }
                        }
                    }, 100);
                }
            }, 500);
        });
        
        // Function initAccessibility moved to app-modern-adapter-fixed.js
    </script>
<!-- Debug tools for quick testing -->
<div id="debug-tools-container-fixed" style="position: fixed; bottom: 20px; right: 20px; background: rgba(30, 30, 45, 0.9); border: 1px solid #00ccff; padding: 10px; z-index: 10000; border-radius: 5px;">
    <h4 style="margin-top: 0; color: #00ccff;">Emergency Debug Tools</h4>
    <button id="create-notes-panel-fixed" style="padding: 5px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0; cursor: pointer; margin-right: 5px;">Create Emergency Notes</button>
    <button id="check-notes-functions-fixed" style="padding: 5px; background: rgba(40,40,60,0.9); border: 1px solid #00ccff; color: #e0e0e0; cursor: pointer;">Check Functions</button>
    <div id="debug-output-fixed" style="margin-top: 10px; color: #e0e0e0; max-width: 300px; max-height: 150px; overflow-y: auto;"></div>
</div>

<script>
    // Add functionality to emergency debug buttons 
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Setting up emergency debug tools');
        
        // Function to log to debug output
        function logToDebug(message) {
            const debugOutput = document.getElementById('debug-output-fixed');
            if (debugOutput) {
                debugOutput.innerHTML += message + '<br>';
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
            console.log('[Emergency Debug]', message);
        }
        
        // Check notes panel functions
        const checkButton = document.getElementById('check-notes-functions-fixed');
        if (checkButton) {
            checkButton.addEventListener('click', function() {
                logToDebug('Checking Panel Functions (Emergency Check):');
                try {
                    logToDebug('- window.createNotesPanel exists: ' + (typeof window.createNotesPanel === 'function'));
                    logToDebug('- window.createPanel exists: ' + (typeof window.createPanel === 'function'));
                    
                    // Check for important variables
                    logToDebug('- Document readyState: ' + document.readyState);
                    
                    // Check for CyberpunkGM namespace
                    logToDebug('- CyberpunkGM exists: ' + (typeof window.CyberpunkGM !== 'undefined'));
                    if (typeof window.CyberpunkGM !== 'undefined') {
                        logToDebug('- CyberpunkGM.createPanel exists: ' + (typeof window.CyberpunkGM.createPanel === 'function'));
                    }
                    
                    // Check loaded scripts for debugging
                    const scripts = document.getElementsByTagName('script');
                    logToDebug(`- ${scripts.length} scripts loaded`);
                    for (let i = 0; i < Math.min(scripts.length, 5); i++) {
                        if (scripts[i].src) {
                            logToDebug(`  - Script ${i+1}: ${scripts[i].src.split('/').pop()}`);
                        }
                    }
                } catch (err) {
                    logToDebug('Error checking functions: ' + err.message);
                }
            });
        } else {
            console.warn('Check button not found');
        }
        
        // Create standalone emergency notes panel
        const createButton = document.getElementById('create-notes-panel-fixed');
        if (createButton) {
            createButton.addEventListener('click', function() {
                logToDebug('Creating Ultra-Emergency Notes Panel (Zero Dependencies)...');
                
                // No try-catch, just step-by-step code with checks
                // Create a basic panel div
                var panel = document.createElement('div');
                var panelId = 'emergency-notes-' + Date.now();
                panel.id = panelId;
                
                // Style the panel
                panel.style.position = 'absolute';
                panel.style.zIndex = '9000';
                panel.style.left = '150px';
                panel.style.top = '100px';
                panel.style.width = '400px';
                panel.style.height = '300px';
                panel.style.backgroundColor = 'rgba(30, 30, 45, 0.85)';
                panel.style.border = '2px solid #ff3333'; // Red border to distinguish as emergency
                panel.style.borderRadius = '4px';
                panel.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.5)';
                
                // Insert the HTML content
                var htmlContent = '';
                
                // Header
                htmlContent += '<div id="' + panelId + '-header" style="display: flex; justify-content: space-between; align-items: center; background-color: rgba(10, 10, 20, 0.9); color: #e0e0e0; padding: 8px; border-bottom: 1px solid #ff3333; cursor: move;">';
                htmlContent += '<span style="font-weight: bold;">100% ZERO DEPENDENCY Notes Panel</span>';
                htmlContent += '<button id="' + panelId + '-close" style="background: none; border: none; color: #e0e0e0; font-size: 18px; cursor: pointer;">&times;</button>';
                htmlContent += '</div>';
                
                // Toolbar
                htmlContent += '<div style="display: flex; padding: 5px; gap: 5px; border-bottom: 1px solid rgba(255, 51, 51, 0.3); background-color: rgba(20, 20, 30, 0.9);">';
                htmlContent += '<button id="' + panelId + '-bold" style="padding: 4px 8px; background: rgba(40,40,60,0.9); border: 1px solid #ff3333; color: #e0e0e0;"><strong>B</strong></button>';
                htmlContent += '<button id="' + panelId + '-italic" style="padding: 4px 8px; background: rgba(40,40,60,0.9); border: 1px solid #ff3333; color: #e0e0e0;"><em>I</em></button>';
                htmlContent += '<button id="' + panelId + '-underline" style="padding: 4px 8px; background: rgba(40,40,60,0.9); border: 1px solid #ff3333; color: #e0e0e0;"><u>U</u></button>';
                htmlContent += '</div>';
                
                // Editor
                htmlContent += '<div id="' + panelId + '-editor" style="flex: 1; padding: 10px; height: 225px; background: rgba(20,20,35,0.9); color: #e0e0e0; outline: none; overflow-y: auto;" contenteditable="true"></div>';
                
                // Set the HTML content
                panel.innerHTML = htmlContent;
                
                // Add the panel to the document
                document.body.appendChild(panel);
                logToDebug('Panel created and added to document');
                
                // Get references to the elements we need
                var closeBtn = document.getElementById(panelId + '-close');
                var header = document.getElementById(panelId + '-header');
                var editor = document.getElementById(panelId + '-editor');
                var boldBtn = document.getElementById(panelId + '-bold');
                var italicBtn = document.getElementById(panelId + '-italic');
                var underlineBtn = document.getElementById(panelId + '-underline');
                
                // Make it closeable if we have the button
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        panel.parentNode.removeChild(panel);
                        logToDebug('Panel removed');
                    };
                }
                
                // Make it draggable if we have the header
                if (header) {
                    header.onmousedown = function(e) {
                        e.preventDefault();
                        
                        var startX = e.clientX;
                        var startY = e.clientY;
                        var startLeft = parseInt(panel.style.left) || 150;
                        var startTop = parseInt(panel.style.top) || 100;
                        
                        function movePanel(e) {
                            panel.style.left = (startLeft + e.clientX - startX) + 'px';
                            panel.style.top = (startTop + e.clientY - startY) + 'px';
                        }
                        
                        function stopMoving() {
                            document.removeEventListener('mousemove', movePanel);
                            document.removeEventListener('mouseup', stopMoving);
                        }
                        
                        document.addEventListener('mousemove', movePanel);
                        document.addEventListener('mouseup', stopMoving);
                    };
                }
                
                // Add formatting buttons functionality if available
                if (editor && boldBtn) {
                    boldBtn.onclick = function() {
                        document.execCommand('bold', false, null);
                        if (editor) editor.focus();
                    };
                }
                
                if (editor && italicBtn) {
                    italicBtn.onclick = function() {
                        document.execCommand('italic', false, null);
                        if (editor) editor.focus();
                    };
                }
                
                if (editor && underlineBtn) {
                    underlineBtn.onclick = function() {
                        document.execCommand('underline', false, null);
                        if (editor) editor.focus();
                    };
                }
                
                // Focus the editor
                if (editor) {
                    setTimeout(function() {
                        editor.focus();
                    }, 100);
                }
                
                logToDebug('Ultra-emergency notes panel ready to use!');
            });
        } else {
            console.warn('Create button not found');
        }
    });
</script>
</body>
</html>