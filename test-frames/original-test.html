<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Original Drag Handler Test</title>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: sans-serif;
            padding: 0;
            margin: 0;
            overflow: hidden;
            height: 100vh;
        }
        
        .draggable-panel {
            position: absolute;
            background-color: #1a1a1a;
            border: 1px solid #444;
            min-width: 300px;
            min-height: 200px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .panel-header {
            background-color: #2a2a2a;
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        
        .panel-content {
            padding: 15px;
        }
        
        .close-button {
            cursor: pointer;
            padding: 0 5px;
        }
        
        .resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10;
            background-color: transparent;
        }
        
        .resize-handle:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <!-- Panels will be created dynamically -->
    
    <script>
        // Original DragHandler class (v1.0)
        class DragHandler {
            constructor() {
                this.currentPanel = null;
                this.initialX = 0;
                this.initialY = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.resizing = false;
                this.resizeHandle = null;
                
                // Test harness additions
                this.metrics = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: performance.now(),
                    panelCount: 0,
                    listenerCount: 0,
                    memory: 0,
                    startTime: 0,
                    dragStartTime: 0,
                    dragDurationSum: 0,
                    dragCount: 0
                };
                
                // Start measuring FPS
                this.updateFPS();
                
                // Report metrics periodically
                setInterval(() => this.reportMetrics(), 1000);
            }
            
            initDraggablePanels(panels) {
                // Record initialization time
                this.metrics.startTime = performance.now();
                
                // Initialize each panel
                panels.forEach(panel => this.makeDraggable(panel));
                
                // Record init completion time
                const initTime = performance.now() - this.metrics.startTime;
                this.metrics.initTime = initTime;
                
                // Update panel count and listener count
                this.metrics.panelCount = panels.length;
                this.metrics.listenerCount = panels.length * 3; // Approx: mousedown, resize, close
                
                console.log(`Initialized ${panels.length} panels in ${initTime.toFixed(2)}ms`);
            }
            
            makeDraggable(panel) {
                const header = panel.querySelector('.panel-header');
                
                // Make draggable by header
                header.addEventListener('mousedown', (e) => {
                    // Prevent default to avoid text selection
                    e.preventDefault();
                    
                    // Bring panel to front
                    this.bringToFront(panel);
                    
                    // Record drag start time for measuring
                    this.metrics.dragStartTime = performance.now();
                    
                    // Get initial position
                    this.initialX = e.clientX;
                    this.initialY = e.clientY;
                    this.offsetX = panel.offsetLeft;
                    this.offsetY = panel.offsetTop;
                    this.currentPanel = panel;
                    
                    // Add event listeners
                    document.addEventListener('mousemove', this.movePanelHandler);
                    document.addEventListener('mouseup', this.stopMovingHandler);
                });
                
                // Add resize functionality
                this.makeResizable(panel);
                
                // Add close button functionality
                const closeButton = panel.querySelector('.close-button');
                if (closeButton) {
                    closeButton.addEventListener('click', () => {
                        panel.remove();
                        this.metrics.panelCount--;
                        this.metrics.listenerCount -= 3;
                    });
                }
            }
            
            makeResizable(panel) {
                // Create resize handle if not present
                if (!panel.querySelector('.resize-handle')) {
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    panel.appendChild(resizeHandle);
                    
                    // Add resize functionality
                    resizeHandle.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        this.bringToFront(panel);
                        this.resizing = true;
                        this.currentPanel = panel;
                        this.resizeHandle = resizeHandle;
                        this.initialX = e.clientX;
                        this.initialY = e.clientY;
                        this.initialWidth = parseFloat(getComputedStyle(panel).width);
                        this.initialHeight = parseFloat(getComputedStyle(panel).height);
                        
                        document.addEventListener('mousemove', this.resizePanelHandler);
                        document.addEventListener('mouseup', this.stopResizingHandler);
                    });
                }
            }
            
            bringToFront(panel) {
                // Get all panels
                const panels = document.querySelectorAll('.draggable-panel');
                
                // Set all panels to z-index 1
                panels.forEach(p => p.style.zIndex = '1');
                
                // Set the current panel to z-index 10
                panel.style.zIndex = '10';
            }
            
            movePanelHandler = (e) => {
                if (this.currentPanel) {
                    // Calculate new position
                    const x = this.offsetX + e.clientX - this.initialX;
                    const y = this.offsetY + e.clientY - this.initialY;
                    
                    // Apply new position
                    this.currentPanel.style.left = `${x}px`;
                    this.currentPanel.style.top = `${y}px`;
                }
            };
            
            stopMovingHandler = () => {
                if (this.currentPanel && this.metrics.dragStartTime > 0) {
                    // Calculate drag duration
                    const dragDuration = performance.now() - this.metrics.dragStartTime;
                    this.metrics.dragDurationSum += dragDuration;
                    this.metrics.dragCount++;
                    this.metrics.dragStartTime = 0;
                }
                
                this.currentPanel = null;
                document.removeEventListener('mousemove', this.movePanelHandler);
                document.removeEventListener('mouseup', this.stopMovingHandler);
            };
            
            resizePanelHandler = (e) => {
                if (this.resizing && this.currentPanel) {
                    // Calculate new dimensions
                    const width = this.initialWidth + e.clientX - this.initialX;
                    const height = this.initialHeight + e.clientY - this.initialY;
                    
                    // Apply new dimensions with minimum size
                    if (width >= 300) this.currentPanel.style.width = `${width}px`;
                    if (height >= 200) this.currentPanel.style.height = `${height}px`;
                }
            };
            
            stopResizingHandler = () => {
                this.resizing = false;
                this.currentPanel = null;
                document.removeEventListener('mousemove', this.resizePanelHandler);
                document.removeEventListener('mouseup', this.stopResizingHandler);
            };
            
            refreshDraggablePanels() {
                const panels = document.querySelectorAll('.draggable-panel');
                this.initDraggablePanels(panels);
            }
            
            // Test harness methods
            updateFPS() {
                const now = performance.now();
                const elapsed = now - this.metrics.lastTime;
                
                this.metrics.frameCount++;
                
                if (elapsed >= 1000) {
                    this.metrics.fps = Math.round((this.metrics.frameCount * 1000) / elapsed);
                    this.metrics.frameCount = 0;
                    this.metrics.lastTime = now;
                    
                    // Update memory usage if available
                    if (window.performance && window.performance.memory) {
                        this.metrics.memory = window.performance.memory.usedJSHeapSize;
                    }
                }
                
                requestAnimationFrame(() => this.updateFPS());
            }
            
            reportMetrics() {
                // Count panels and event listeners
                this.metrics.panelCount = document.querySelectorAll('.draggable-panel').length;
                
                // Post metrics to parent window
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'metrics-update',
                        version: 'original',
                        metrics: {
                            fps: this.metrics.fps,
                            panelCount: this.metrics.panelCount,
                            listenerCount: this.metrics.listenerCount,
                            memory: this.metrics.memory
                        }
                    }, '*');
                }
            }
            
            // Benchmark methods
            runBenchmark() {
                console.log('Running benchmark...');
                
                // Reset metrics for benchmarking
                this.metrics.dragDurationSum = 0;
                this.metrics.dragCount = 0;
                
                // Test 1: Initialization time (already captured)
                const initResult = this.metrics.initTime || 0;
                this.reportBenchmarkResult('init', initResult);
                
                // Test 2: Drag performance (measure FPS during drag)
                this.simulateDrags(5).then(dragFPS => {
                    this.reportBenchmarkResult('drag', dragFPS);
                    
                    // Test 3: Multiple panels performance
                    this.testMultiplePanels().then(multiFPS => {
                        this.reportBenchmarkResult('multiple', multiFPS);
                        
                        // Test 4: Memory usage
                        const memoryUsage = this.metrics.memory / (1024 * 1024); // Convert to MB
                        this.reportBenchmarkResult('memory', parseFloat(memoryUsage.toFixed(1)), true);
                    });
                });
            }
            
            async simulateDrags(count) {
                // Create a test panel if none exists
                if (document.querySelectorAll('.draggable-panel').length === 0) {
                    createPanel('Test Panel', 100, 100);
                    this.refreshDraggablePanels();
                }
                
                const panel = document.querySelector('.draggable-panel');
                if (!panel) return 0;
                
                // Initial FPS measurement
                const initialFPS = this.metrics.fps;
                const dragFPSArray = [];
                
                for (let i = 0; i < count; i++) {
                    // Simulate drag
                    await this.simulateDrag(panel, 100, 100, 300, 300);
                    
                    // Capture FPS after drag
                    dragFPSArray.push(this.metrics.fps);
                    
                    // Wait a moment between drags
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Calculate average drag FPS
                const avgDragFPS = dragFPSArray.reduce((sum, fps) => sum + fps, 0) / dragFPSArray.length;
                return Math.round(avgDragFPS);
            }
            
            async simulateDrag(panel, startX, startY, endX, endY) {
                const header = panel.querySelector('.panel-header');
                if (!header) return;
                
                // Simulate mousedown
                const mousedownEvent = new MouseEvent('mousedown', {
                    bubbles: true,
                    cancelable: true,
                    clientX: startX,
                    clientY: startY
                });
                header.dispatchEvent(mousedownEvent);
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Simulate mousemove
                const mousemoveEvent = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    clientX: endX,
                    clientY: endY
                });
                document.dispatchEvent(mousemoveEvent);
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Simulate mouseup
                const mouseupEvent = new MouseEvent('mouseup', {
                    bubbles: true,
                    cancelable: true,
                    clientX: endX,
                    clientY: endY
                });
                document.dispatchEvent(mouseupEvent);
                
                // Wait for completion
                return new Promise(resolve => setTimeout(resolve, 200));
            }
            
            async testMultiplePanels() {
                // Ensure we have multiple panels
                const panelCount = document.querySelectorAll('.draggable-panel').length;
                
                if (panelCount < 10) {
                    // Create additional panels
                    const countToAdd = 10 - panelCount;
                    for (let i = 0; i < countToAdd; i++) {
                        const x = 100 + Math.floor(Math.random() * 500);
                        const y = 100 + Math.floor(Math.random() * 300);
                        createPanel(`Panel ${panelCount + i + 1}`, x, y);
                    }
                    
                    this.refreshDraggablePanels();
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Move multiple panels simultaneously
                const panels = document.querySelectorAll('.draggable-panel');
                const moveTasks = [];
                
                panels.forEach((panel, i) => {
                    // Only move half the panels to avoid overloading
                    if (i % 2 === 0) {
                        const startX = 100 + (i * 20);
                        const startY = 100 + (i * 20);
                        const endX = 300 + (i * 20);
                        const endY = 300 + (i * 20);
                        
                        moveTasks.push(this.simulateDrag(panel, startX, startY, endX, endY));
                    }
                });
                
                // Wait for all movements to complete
                await Promise.all(moveTasks);
                
                // Return the measured FPS during multiple panel movement
                return this.metrics.fps;
            }
            
            reportBenchmarkResult(benchmarkType, result, isLastTest = false) {
                // Post result to parent window
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'benchmark-result',
                        benchmarkType,
                        version: 'original',
                        results: result,
                        isLastTest
                    }, '*');
                }
            }
        }
        
        // Create a panel element
        function createPanel(title, left, top) {
            const panel = document.createElement('div');
            panel.className = 'draggable-panel';
            panel.style.left = `${left}px`;
            panel.style.top = `${top}px`;
            panel.style.width = '400px';
            panel.style.height = '300px';
            
            const header = document.createElement('div');
            header.className = 'panel-header';
            header.innerHTML = `${title} <span class="close-button">Ã—</span>`;
            
            const content = document.createElement('div');
            content.className = 'panel-content';
            content.innerHTML = `
                <p>Original drag handler (v1.0)</p>
                <p>Panel content goes here.</p>
            `;
            
            panel.appendChild(header);
            panel.appendChild(content);
            document.body.appendChild(panel);
            
            return panel;
        }
        
        // Initialize drag handler
        const dragHandler = new DragHandler();
        
        // Create initial test panels
        function initPanels() {
            for (let i = 0; i < 3; i++) {
                createPanel(`Panel ${i+1}`, 100 + i*50, 100 + i*30);
            }
            
            dragHandler.refreshDraggablePanels();
        }
        
        // Initialize
        initPanels();
        
        // Handle messages from parent frame
        window.addEventListener('message', (event) => {
            // Verify origin for security
            if (event.origin !== window.location.origin) return;
            
            const data = event.data;
            if (!data || !data.command) return;
            
            // Handle commands
            switch (data.command) {
                case 'reset':
                    // Remove all panels
                    document.querySelectorAll('.draggable-panel').forEach(panel => panel.remove());
                    // Create initial panels
                    initPanels();
                    break;
                    
                case 'add-panels':
                    // Add specified number of panels
                    const count = data.count || 10;
                    for (let i = 0; i < count; i++) {
                        const x = 100 + Math.floor(Math.random() * 500);
                        const y = 100 + Math.floor(Math.random() * 300);
                        createPanel(`New Panel ${i+1}`, x, y);
                    }
                    dragHandler.refreshDraggablePanels();
                    break;
                    
                case 'run-benchmark':
                    // Run benchmark tests
                    dragHandler.runBenchmark();
                    break;
            }
        });
    </script>
</body>
</html>